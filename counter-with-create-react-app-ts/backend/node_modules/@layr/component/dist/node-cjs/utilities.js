"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinAttributePath = exports.composeDescription = exports.assertIsComponentMixin = exports.isComponentMixin = exports.getComponentFromComponentMap = exports.createComponentMap = exports.getComponentInstanceTypeFromComponentName = exports.getComponentClassTypeFromComponentName = exports.assertIsComponentType = exports.isComponentType = exports.getComponentNameFromComponentInstanceType = exports.getComponentNameFromComponentClassType = exports.assertIsComponentName = exports.isComponentName = exports.ensureComponentInstance = exports.ensureComponentClass = exports.assertIsComponentClassOrInstance = exports.assertIsComponentInstance = exports.assertIsComponentClass = exports.isComponentClassOrInstance = exports.isComponentInstance = exports.isComponentClass = void 0;
const tslib_1 = require("tslib");
const core_helpers_1 = require("core-helpers");
const compact_1 = tslib_1.__importDefault(require("lodash/compact"));
/**
 * Returns whether the specified value is a component class.
 *
 * @param value A value of any type.
 *
 * @returns A boolean.
 *
 * @category Utilities
 */
function isComponentClass(value) {
    return typeof (value === null || value === void 0 ? void 0 : value.isComponent) === 'function';
}
exports.isComponentClass = isComponentClass;
/**
 * Returns whether the specified value is a component instance.
 *
 * @param value A value of any type.
 *
 * @returns A boolean.
 *
 * @category Utilities
 */
function isComponentInstance(value) {
    var _a;
    return typeof ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.isComponent) === 'function';
}
exports.isComponentInstance = isComponentInstance;
/**
 * Returns whether the specified value is a component class or instance.
 *
 * @param value A value of any type.
 *
 * @returns A boolean.
 *
 * @category Utilities
 */
function isComponentClassOrInstance(value) {
    var _a;
    return (typeof (value === null || value === void 0 ? void 0 : value.isComponent) === 'function' ||
        typeof ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.isComponent) === 'function');
}
exports.isComponentClassOrInstance = isComponentClassOrInstance;
/**
 * Throws an error if the specified value is not a component class.
 *
 * @param value A value of any type.
 *
 * @category Utilities
 */
function assertIsComponentClass(value) {
    if (!isComponentClass(value)) {
        throw new Error(`Expected a component class, but received a value of type '${core_helpers_1.getTypeOf(value)}'`);
    }
}
exports.assertIsComponentClass = assertIsComponentClass;
/**
 * Throws an error if the specified value is not a component instance.
 *
 * @param value A value of any type.
 *
 * @category Utilities
 */
function assertIsComponentInstance(value) {
    if (!isComponentInstance(value)) {
        throw new Error(`Expected a component instance, but received a value of type '${core_helpers_1.getTypeOf(value)}'`);
    }
}
exports.assertIsComponentInstance = assertIsComponentInstance;
/**
 * Throws an error if the specified value is not a component class or instance.
 *
 * @param value A value of any type.
 *
 * @category Utilities
 */
function assertIsComponentClassOrInstance(value) {
    if (!isComponentClassOrInstance(value)) {
        throw new Error(`Expected a component class or instance, but received a value of type '${core_helpers_1.getTypeOf(value)}'`);
    }
}
exports.assertIsComponentClassOrInstance = assertIsComponentClassOrInstance;
/**
 * Ensures that the specified component is a class. If you specify a component instance (or prototype), the class of the component is returned. If you specify a component class, it is returned as is.
 *
 * @param component A component class or instance.
 *
 * @returns A component class.
 *
 * @example
 * ```
 * ensureComponentClass(movie) => Movie
 * ensureComponentClass(Movie.prototype) => Movie
 * ensureComponentClass(Movie) => Movie
 * ```
 *
 * @category Utilities
 */
function ensureComponentClass(component) {
    if (isComponentClass(component)) {
        return component;
    }
    if (isComponentInstance(component)) {
        return component.constructor;
    }
    throw new Error(`Expected a component class or instance, but received a value of type '${core_helpers_1.getTypeOf(component)}'`);
}
exports.ensureComponentClass = ensureComponentClass;
/**
 * Ensures that the specified component is an instance (or prototype). If you specify a component class, the component prototype is returned. If you specify a component instance (or prototype), it is returned as is.
 *
 * @param component A component class or instance.
 *
 * @returns A component instance (or prototype).
 *
 * @example
 * ```
 * ensureComponentInstance(Movie) => Movie.prototype
 * ensureComponentInstance(Movie.prototype) => Movie.prototype
 * ensureComponentInstance(movie) => movie
 * ```
 *
 * @category Utilities
 */
function ensureComponentInstance(component) {
    if (isComponentClass(component)) {
        return component.prototype;
    }
    if (isComponentInstance(component)) {
        return component;
    }
    throw new Error(`Expected a component class or instance, but received a value of type '${core_helpers_1.getTypeOf(component)}'`);
}
exports.ensureComponentInstance = ensureComponentInstance;
const COMPONENT_NAME_PATTERN = /^[A-Z][A-Za-z0-9_]*$/;
/**
 * Returns whether the specified string is a valid component name. The rule is the same as for typical JavaScript class names.
 *
 * @param name The string to check.
 *
 * @returns A boolean.
 *
 * @example
 * ```
 * isComponentName('Movie') => true
 * isComponentName('Movie123') => true
 * isComponentName('Awesome_Movie') => true
 * isComponentName('123Movie') => false
 * isComponentName('Awesome-Movie') => false
 * isComponentName('movie') => false
 * ```
 *
 * @category Utilities
 */
function isComponentName(name) {
    return COMPONENT_NAME_PATTERN.test(name);
}
exports.isComponentName = isComponentName;
/**
 * Throws an error if the specified string is not a valid component name.
 *
 * @param name The string to check.
 *
 * @category Utilities
 */
function assertIsComponentName(name) {
    if (name === '') {
        throw new Error('A component name cannot be empty');
    }
    if (!isComponentName(name)) {
        throw new Error(`The specified component name ('${name}') is invalid`);
    }
}
exports.assertIsComponentName = assertIsComponentName;
/**
 * Transforms a component class type into a component name.
 *
 * @param name A string representing a component class type.
 *
 * @returns A component name.
 *
 * @example
 * ```
 * getComponentNameFromComponentClassType('typeof Movie') => 'Movie'
 * ```
 *
 * @category Utilities
 */
function getComponentNameFromComponentClassType(type) {
    assertIsComponentType(type, { allowInstances: false });
    return type.slice('typeof '.length);
}
exports.getComponentNameFromComponentClassType = getComponentNameFromComponentClassType;
/**
 * Transforms a component instance type into a component name.
 *
 * @param name A string representing a component instance type.
 *
 * @returns A component name.
 *
 * @example
 * ```
 * getComponentNameFromComponentInstanceType('Movie') => 'Movie'
 * ```
 *
 * @category Utilities
 */
function getComponentNameFromComponentInstanceType(type) {
    assertIsComponentType(type, { allowClasses: false });
    return type;
}
exports.getComponentNameFromComponentInstanceType = getComponentNameFromComponentInstanceType;
const COMPONENT_CLASS_TYPE_PATTERN = /^typeof [A-Z][A-Za-z0-9_]*$/;
const COMPONENT_INSTANCE_TYPE_PATTERN = /^[A-Z][A-Za-z0-9_]*$/;
/**
 * Returns whether the specified string is a valid component type.
 *
 * @param name The string to check.
 * @param [options.allowClasses] A boolean specifying whether component class types are allowed (default: `true`).
 * @param [options.allowInstances] A boolean specifying whether component instance types are allowed (default: `true`).
 *
 * @returns A boolean.
 *
 * @example
 * ```
 * isComponentType('typeof Movie') => true
 * isComponentType('Movie') => true
 * isComponentType('typeof Awesome-Movie') => false
 * isComponentType('movie') => false
 * isComponentType('typeof Movie', {allowClasses: false}) => false
 * isComponentType('Movie', {allowInstances: false}) => false
 * ```
 *
 * @category Utilities
 */
function isComponentType(type, { allowClasses = true, allowInstances = true } = {}) {
    if (allowClasses && COMPONENT_CLASS_TYPE_PATTERN.test(type)) {
        return 'componentClassType';
    }
    if (allowInstances && COMPONENT_INSTANCE_TYPE_PATTERN.test(type)) {
        return 'componentInstanceType';
    }
    return false;
}
exports.isComponentType = isComponentType;
/**
 * Throws an error if the specified string is not a valid component type.
 *
 * @param name The string to check.
 * @param [options.allowClasses] A boolean specifying whether component class types are allowed (default: `true`).
 * @param [options.allowInstances] A boolean specifying whether component instance types are allowed (default: `true`).
 *
 * @category Utilities
 */
function assertIsComponentType(type, { allowClasses = true, allowInstances = true } = {}) {
    if (type === '') {
        throw new Error('A component type cannot be empty');
    }
    const isComponentTypeResult = isComponentType(type, { allowClasses, allowInstances });
    if (isComponentTypeResult === false) {
        throw new Error(`The specified component type ('${type}') is invalid`);
    }
    return isComponentTypeResult;
}
exports.assertIsComponentType = assertIsComponentType;
/**
 * Transforms a component name into a component class type.
 *
 * @param name A component name.
 *
 * @returns A component class type.
 *
 * @example
 * ```
 * getComponentClassTypeFromComponentName('Movie') => 'typeof Movie'
 * ```
 *
 * @category Utilities
 */
function getComponentClassTypeFromComponentName(name) {
    assertIsComponentName(name);
    return `typeof ${name}`;
}
exports.getComponentClassTypeFromComponentName = getComponentClassTypeFromComponentName;
/**
 * Transforms a component name into a component instance type.
 *
 * @param name A component name.
 *
 * @returns A component instance type.
 *
 * @example
 * ```
 * getComponentInstanceTypeFromComponentName('Movie') => 'Movie'
 * ```
 *
 * @category Utilities
 */
function getComponentInstanceTypeFromComponentName(name) {
    assertIsComponentName(name);
    return name;
}
exports.getComponentInstanceTypeFromComponentName = getComponentInstanceTypeFromComponentName;
function createComponentMap(components = []) {
    const componentMap = Object.create(null);
    for (const component of components) {
        assertIsComponentClass(component);
        componentMap[component.getComponentName()] = component;
    }
    return componentMap;
}
exports.createComponentMap = createComponentMap;
function getComponentFromComponentMap(componentMap, name) {
    assertIsComponentName(name);
    const component = componentMap[name];
    if (component === undefined) {
        throw new Error(`The component '${name}' is unknown`);
    }
    return component;
}
exports.getComponentFromComponentMap = getComponentFromComponentMap;
function isComponentMixin(value) {
    return typeof value === 'function' && core_helpers_1.getFunctionName(value) !== '' && !core_helpers_1.isES2015Class(value);
}
exports.isComponentMixin = isComponentMixin;
function assertIsComponentMixin(value) {
    if (!isComponentMixin(value)) {
        throw new Error(`Expected a component mixin, but received a value of type '${core_helpers_1.getTypeOf(value)}'`);
    }
}
exports.assertIsComponentMixin = assertIsComponentMixin;
function composeDescription(description) {
    let composedDescription = compact_1.default(description).join(', ');
    if (composedDescription !== '') {
        composedDescription = ` (${composedDescription})`;
    }
    return composedDescription;
}
exports.composeDescription = composeDescription;
function joinAttributePath(path) {
    const compactedPath = compact_1.default(path);
    if (compactedPath.length === 0) {
        return '';
    }
    if (compactedPath.length === 1) {
        return compactedPath[0];
    }
    const [first, second] = compactedPath;
    if (second.startsWith('[')) {
        return `${first}${second}`;
    }
    return `${first}.${second}`;
}
exports.joinAttributePath = joinAttributePath;
//# sourceMappingURL=utilities.js.map