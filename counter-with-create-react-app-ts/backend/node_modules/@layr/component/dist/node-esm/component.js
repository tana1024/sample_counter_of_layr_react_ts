import { Observable } from '@layr/observable';
import { hasOwnProperty, isPrototypeOf, getTypeOf, isPlainObject, getFunctionName, assertIsFunction } from 'core-helpers';
import { possiblyAsync } from 'possibly-async';
import cuid from 'cuid';
import { Property, Attribute, isAttributeClass, isAttributeInstance, isIdentifierAttributeInstance, PrimaryIdentifierAttribute, isPrimaryIdentifierAttributeInstance, SecondaryIdentifierAttribute, isSecondaryIdentifierAttributeInstance, createAttributeSelectorFromNames, createAttributeSelectorFromAttributes, getFromAttributeSelector, setWithinAttributeSelector, mergeAttributeSelectors, normalizeAttributeSelector, Method, isMethodInstance } from './properties';
import { IdentityMap } from './identity-map';
import { clone } from './cloning';
import { merge } from './merging';
import { deserialize } from './deserialization';
import { isComponentClass, isComponentInstance, isComponentClassOrInstance, assertIsComponentClass, assertIsComponentInstance, ensureComponentClass, assertIsComponentName, getComponentNameFromComponentClassType, getComponentNameFromComponentInstanceType, assertIsComponentType, getComponentClassTypeFromComponentName, getComponentInstanceTypeFromComponentName, joinAttributePath } from './utilities';
/**
 * *Inherits from [`Observable`](https://layrjs.com/docs/v1/reference/observable#observable-class).*
 *
 * A component is an elementary building block allowing you to define your data models and implement the business logic of your application. Typically, an application is composed of several components that are connected to each other by using the [`@provide()`](https://layrjs.com/docs/v1/reference/component#provide-decorator) and [`@consume()`](https://layrjs.com/docs/v1/reference/component#consume-decorator) decorators.
 *
 * #### Usage
 *
 * Just extend the `Component` class to define a component with some attributes and methods that are specific to your application.
 *
 * For example, a `Movie` component with a `title` attribute and a `play()` method could be defined as follows:
 *
 * ```
 * // JS
 *
 * import {Component} from '@layr/component';
 *
 * class Movie extends Component {
 *   ﹫attribute('string') title;
 *
 *   ﹫method() play() {
 *     console.log(`Playing '${this.title}...'`);
 *   }
 * }
 * ```
 *
 * ```
 * // TS
 *
 * import {Component} from '@layr/component';
 *
 * class Movie extends Component {
 *   ﹫attribute('string') title!: string;
 *
 *   ﹫method() play() {
 *     console.log(`Playing '${this.title}...'`);
 *   }
 * }
 * ```
 *
 * The [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) and [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator) decorators allows you to get the full power of Layr, such as attribute type checking, or remote method invocation.
 *
 * Once you have defined a component, you can use it as any JavaScript class:
 *
 * ```
 * const movie = new Movie({title: 'Inception'});
 *
 * movie.play(); // => 'Playing Inception...'
 * ```
 *
 * #### Nesting Components
 *
 * Components can be nested either by embedding or by referencing.
 *
 * ##### Embedding Components
 *
 * Use the [`EmbeddedComponent`](https://layrjs.com/docs/v1/reference/embedded-component) class to embed a component into another component. An embedded component is strongly attached to the parent component that owns it, and it cannot "live" by itself like a regular component.
 *
 * Here are some characteristics of an embedded component:
 *
 * - An embedded component has one parent only, and therefore cannot be embedded in more than one component.
 * - When the parent of an embedded component is [validated](https://layrjs.com/docs/v1/reference/validator), the embedded component is validated as well.
 * - When the parent of an embedded component is loaded, saved, or deleted (using a [`StorableComponent`](https://layrjs.com/docs/v1/reference/storable#storage-operations) method), the embedded component is loaded, saved, or deleted as well.
 *
 * See the [`EmbeddedComponent`](https://layrjs.com/docs/v1/reference/embedded-component) class for an example of use.
 *
 * ##### Referencing Components
 *
 * Any non-embedded component can be referenced by another component. Contrary to an embedded component, a referenced component is an independent entity that can "live" by itself. So a referenced component behaves like a regular JavaScript object that is referenced by another object.
 *
 * Here are some characteristics of a referenced component:
 *
 * - A referenced component can be referenced by any number of components.
 * - When a component holding a reference to another component is [validated](https://layrjs.com/docs/v1/reference/validator), the referenced component is considered as an independent entity, and is therefore not automatically validated.
 * - When a component holding a reference to another component is loaded, saved, or deleted (using a [`StorableComponent`](https://layrjs.com/docs/v1/reference/storable#storage-operations) method), the referenced component can be loaded in the same operation, but it has to be saved or deleted independently.
 *
 * For example, let's say we have a `Director` component defined as follows:
 *
 * ```
 * // JS
 *
 * class Director extends Component {
 *   ﹫attribute('string') fullName;
 * }
 * ```
 *
 * ```
 * // TS
 *
 * class Director extends Component {
 *   ﹫attribute('string') fullName!: string;
 * }
 * ```
 *
 * Next, we can add an attribute to the `Movie` component to store a reference to a `Director`:
 *
 * ```
 * // JS
 *
 * class Movie extends Component {
 *   ﹫provide() static Director = Director;
 *
 *   // ...
 *
 *   ﹫attribute('Director') director;
 * }
 * ```
 *
 * ```
 * // TS
 *
 * class Movie extends Component {
 *   ﹫provide() static Director = Director;
 *
 *   // ...
 *
 *   ﹫attribute('Director') director!: Director;
 * }
 * ```
 *
 * > Note that to be able to specify the `'Director'` type for the `director` attribute, you first have to provide the `Director` component to the `Movie` component by using the [`@provide()`](https://layrjs.com/docs/v1/reference/component#provide-decorator) decorator.
 *
 *  Then, to create a `Movie` with a `Director`, we can do something like:
 *
 * ```
 * const movie = new Movie({
 *   title: 'Inception',
 *   director: new Movie.Director({fullName: 'Christopher Nolan'})
 * });
 *
 * movie.title; // => 'Inception'
 * movie.director.fullName; // => 'Christopher Nolan'
 * ```
 */
export class Component extends Observable(Object) {
    // === Creation ===
    /**
     * Creates an instance of a component class.
     *
     * @param [object] An optional object specifying the value of the component attributes.
     *
     * @returns The component instance that was created.
     *
     * @example
     * ```
     * // JS
     *
     * import {Component, attribute} from '﹫layr/component';
     *
     * class Movie extends Component {
     *   ﹫attribute('string') title;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title // => 'Inception'
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * import {Component, attribute} from '﹫layr/component';
     *
     * class Movie extends Component {
     *   ﹫attribute('string') title!: string;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title // => 'Inception'
     * ```
     *
     * @category Creation
     */
    constructor(object = {}) {
        super();
        this.markAsNew();
        for (const attribute of this.getAttributes()) {
            const name = attribute.getName();
            let value;
            if (hasOwnProperty(object, name)) {
                value = object[name];
            }
            else {
                if (attribute.isControlled()) {
                    continue; // Controlled attributes should not be set
                }
                value = attribute.evaluateDefault();
            }
            attribute.setValue(value);
            attribute._fixDecoration();
        }
    }
    static create(object = {}, options = {}) {
        const { isNew = true, source, attributeSelector = isNew ? true : {}, attributeFilter, initialize = true } = options;
        const component = Object.create(this.prototype);
        component.setIsNewMark(isNew, { source });
        // Always include attributes present in the specified object
        const fullAttributeSelector = mergeAttributeSelectors(attributeSelector, createAttributeSelectorFromNames(Object.keys(object)));
        return possiblyAsync(possiblyAsync.forEach(component.getAttributes({ attributeSelector: fullAttributeSelector }), (attribute) => {
            return possiblyAsync(attributeFilter !== undefined ? attributeFilter.call(component, attribute) : true, (isNotFilteredOut) => {
                if (isNotFilteredOut) {
                    const name = attribute.getName();
                    let value;
                    if (hasOwnProperty(object, name)) {
                        value = object[name];
                    }
                    else {
                        if (attribute.isControlled()) {
                            return; // Controlled attributes should not be set
                        }
                        value = isNew ? attribute.evaluateDefault() : undefined;
                    }
                    attribute.setValue(value, { source });
                }
            });
        }), () => (initialize ? possiblyAsync(component.initialize(), () => component) : component));
    }
    // === Initialization ===
    /**
     * A (possibly async) method that is called automatically when the component class is deserialized. You can override this method in your component subclasses to implement your initialization logic.
     *
     * @category Initialization
     * @possiblyasync
     */
    static initialize() { }
    /**
     * A (possibly async) method that is called automatically when the component instance is created or deserialized. You can override this method in your component subclasses to implement your initialization logic.
     *
     * @category Initialization
     * @possiblyasync
     */
    initialize() { }
    // === Naming ===
    static getBaseComponentName() {
        return 'Component';
    }
    /**
     * Returns the name of the component, which is usually the name of the corresponding class.
     *
     * @returns A string.
     *
     * @example
     * ```
     * Movie.getComponentName(); // => 'Movie'
     * ```
     *
     * @category Naming
     */
    static getComponentName() {
        const name = this.name;
        if (typeof name === 'string' && name !== '') {
            return name;
        }
        throw new Error('The name of the component is missing');
    }
    /**
     * Sets the name of the component. As the name of a component is usually inferred from the name of its class, this method should not be used so often.
     *
     * @param name The name you wish for the component.
     *
     * @example
     * ```
     * Movie.getComponentName(); // => 'Movie'
     * Movie.setComponentName('Film');
     * Movie.getComponentName(); // => 'Film'
     * ```
     *
     * @category Naming
     */
    static setComponentName(name) {
        assertIsComponentName(name);
        Object.defineProperty(this, 'name', { value: name });
    }
    /**
     * Returns the path of the component starting from its root component.
     *
     * For example, if a `Backend` component provides a `Movie` component, this method will return `'Backend.Movie'` when called on the `Movie` component.
     *
     * @returns A string.
     *
     * @example
     * ```
     * class Movie extends Component {}
     *
     * Movie.getComponentPath(); // => 'Movie'
     *
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Movie.getComponentPath(); // => 'Backend.Movie'
     * ```
     *
     * @category Naming
     */
    static getComponentPath() {
        let path = [];
        let currentComponent = this;
        while (true) {
            path.unshift(currentComponent.getComponentName());
            const componentProvider = currentComponent.getComponentProvider();
            if (componentProvider === currentComponent) {
                break;
            }
            currentComponent = componentProvider;
        }
        return path.join('.');
    }
    // === Typing ===
    static getBaseComponentType() {
        return getComponentClassTypeFromComponentName(this.getBaseComponentName());
    }
    getBaseComponentType() {
        return getComponentInstanceTypeFromComponentName(this.constructor.getBaseComponentName());
    }
    /**
     * Returns the type of the component class. A component class type is composed of the component class name prefixed with the string `'typeof '`.
     *
     * For example, with a component class named `'Movie'`, this method will return `'typeof Movie'`.
     *
     * @returns A string.
     *
     * @example
     * ```
     * Movie.getComponentType(); // => 'typeof Movie'
     * ```
     *
     * @category Typing
     */
    static getComponentType() {
        return getComponentClassTypeFromComponentName(this.getComponentName());
    }
    /**
     * Returns the type of the component instance. A component instance type is equivalent to the component class name.
     *
     * For example, with a component class named `'Movie'`, this method will return `'Movie'` when called on a `Movie` instance.
     *
     * @returns A string.
     *
     * @example
     * ```
     * movie.getComponentType(); // => 'Movie'
     * Movie.prototype.getComponentType(); // => 'Movie'
     * ```
     *
     * @category Typing
     */
    getComponentType() {
        return getComponentInstanceTypeFromComponentName(this.constructor.getComponentName());
    }
    /**
     * Returns whether the component instance is marked as new or not.
     *
     * @alias isNew
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * let movie = new Movie();
     * movie.getIsNewMark(); // => true
     *
     * movie = Movie.recreate();
     * movie.getIsNewMark(); // => false
     * ```
     *
     * @category isNew Mark
     */
    getIsNewMark() {
        return this.__isNew === true;
    }
    /**
     * Sets whether the component instance is marked as new or not.
     *
     * @param isNew A boolean specifying if the component instance should be marked as new or not.
     *
     * @example
     * ```
     * const movie = new Movie();
     * movie.getIsNewMark(); // => true
     * movie.setIsNewMark(false);
     * movie.getIsNewMark(); // => false
     * ```
     *
     * @category isNew Mark
     */
    setIsNewMark(isNew, { source } = {}) {
        Object.defineProperty(this, '__isNew', { value: isNew, configurable: true });
        this.setIsNewMarkSource(source);
    }
    /**
     * Returns whether the component instance is marked as new or not.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * let movie = new Movie();
     * movie.isNew(); // => true
     *
     * movie = Movie.recreate();
     * movie.isNew(); // => false
     * ```
     *
     * @category isNew Mark
     */
    isNew() {
        return this.getIsNewMark();
    }
    /**
     * Marks the component instance as new.
     *
     * This method is a shortcut for `setIsNewMark(true)`.
     *
     * @category isNew Mark
     */
    markAsNew({ source } = {}) {
        this.setIsNewMark(true, { source });
    }
    /**
     * Marks the component instance as not new.
     *
     * This method is a shortcut for `setIsNewMark(false)`.
     *
     * @category isNew Mark
     */
    markAsNotNew({ source } = {}) {
        this.setIsNewMark(false, { source });
    }
    getIsNewMarkSource() {
        return this.__isNewSource !== undefined ? this.__isNewSource : 0;
    }
    setIsNewMarkSource(source = 0) {
        Object.defineProperty(this, '__isNewSource', { value: source, configurable: true });
    }
    // === Observability ===
    /**
     * See the methods that are inherited from the [`Observable`](https://layrjs.com/docs/v1/reference/observable#observable-class) class.
     *
     * @category Observability
     */
    // === Embeddability ===
    /**
     * Returns whether the component is an [`EmbeddedComponent`](https://layrjs.com/docs/v1/reference/embedded-component).
     *
     * @returns A boolean.
     *
     * @category Embeddability
     */
    static isEmbedded() {
        return false;
    }
    // === Properties ===
    static getPropertyClass(type) {
        if (type === 'Property') {
            return Property;
        }
        if (type === 'Attribute') {
            return Attribute;
        }
        if (type === 'PrimaryIdentifierAttribute') {
            return PrimaryIdentifierAttribute;
        }
        if (type === 'SecondaryIdentifierAttribute') {
            return SecondaryIdentifierAttribute;
        }
        if (type === 'Method') {
            return Method;
        }
        throw new Error(`The specified property type ('${type}') is unknown`);
    }
    /**
     * Gets a property of the component.
     *
     * @param name The name of the property to get.
     *
     * @returns An instance of a [`Property`](https://layrjs.com/docs/v1/reference/property) (or a subclass of [`Property`](https://layrjs.com/docs/v1/reference/property) such as [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method), etc.).
     *
     * @example
     * ```
     * movie.getProperty('title'); // => 'title' attribute property
     * movie.getProperty('play'); // => 'play()' method property
     * ```
     *
     * @category Properties
     */
    static get getProperty() {
        return this.prototype.getProperty;
    }
    /**
     * Gets a property of the component.
     *
     * @param name The name of the property to get.
     *
     * @returns An instance of a [`Property`](https://layrjs.com/docs/v1/reference/property) (or a subclass of [`Property`](https://layrjs.com/docs/v1/reference/property) such as [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method), etc.).
     *
     * @example
     * ```
     * movie.getProperty('title'); // => 'title' attribute property
     * movie.getProperty('play'); // => 'play()' method property
     * ```
     *
     * @category Properties
     */
    getProperty(name, options = {}) {
        const { autoFork = true } = options;
        const property = this.__getProperty(name, { autoFork });
        if (property === undefined) {
            throw new Error(`The property '${name}' is missing (${this.describeComponent()})`);
        }
        return property;
    }
    /**
     * Returns whether the component has the specified property.
     *
     * @param name The name of the property to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasProperty('title'); // => true
     * movie.hasProperty('play'); // => true
     * movie.hasProperty('name'); // => false
     * ```
     *
     * @category Properties
     */
    static get hasProperty() {
        return this.prototype.hasProperty;
    }
    /**
     * Returns whether the component has the specified property.
     *
     * @param name The name of the property to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasProperty('title'); // => true
     * movie.hasProperty('play'); // => true
     * movie.hasProperty('name'); // => false
     * ```
     *
     * @category Properties
     */
    hasProperty(name) {
        return this.__getProperty(name, { autoFork: false }) !== undefined;
    }
    static get __getProperty() {
        return this.prototype.__getProperty;
    }
    __getProperty(name, options) {
        const { autoFork } = options;
        const properties = this.__getProperties();
        let property = properties[name];
        if (property === undefined) {
            return undefined;
        }
        if (autoFork && property.getParent() !== this) {
            property = property.fork(this);
            properties[name] = property;
        }
        return property;
    }
    /**
     * Defines a property in the component. Typically, instead of using this method, you would rather use a decorator such as [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) or [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator).
     *
     * @param name The name of the property to define.
     * @param PropertyClass The class of the property (e.g., [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method)) to use.
     * @param [propertyOptions] The options to create the `PropertyClass`.
     *
     * @returns The property that was created.
     *
     * @example
     * ```
     * Movie.prototype.setProperty('title', Attribute, {valueType: 'string'});
     * ```
     *
     * @category Properties
     */
    static get setProperty() {
        return this.prototype.setProperty;
    }
    setProperty(name, PropertyClass, propertyOptions = {}) {
        let property = this.hasProperty(name) ? this.getProperty(name) : undefined;
        if (property === undefined) {
            property = new PropertyClass(name, this, propertyOptions);
            const properties = this.__getProperties();
            properties[name] = property;
        }
        else {
            if (getTypeOf(property) !== getTypeOf(PropertyClass.prototype)) {
                throw new Error(`Cannot change the type of a property (${property.describe()})`);
            }
            property.setOptions(propertyOptions);
        }
        if (isAttributeClass(PropertyClass)) {
            const descriptor = {
                configurable: true,
                enumerable: true,
                get() {
                    return this.getAttribute(name).getValue();
                },
                set(value) {
                    this.getAttribute(name).setValue(value);
                }
            };
            Object.defineProperty(this, name, descriptor);
        }
        return property;
    }
    /**
     * Removes a property from the component. If the specified property doesn't exist, nothing happens.
     *
     * @param name The name of the property to remove.
     *
     * @returns A boolean.
     *
     * @category Properties
     */
    static get deleteProperty() {
        return this.prototype.deleteProperty;
    }
    /**
     * Removes a property from the component. If the specified property doesn't exist, nothing happens.
     *
     * @param name The name of the property to remove.
     *
     * @returns A boolean.
     *
     * @category Properties
     */
    deleteProperty(name) {
        const properties = this.__getProperties();
        if (!hasOwnProperty(properties, name)) {
            return false;
        }
        delete properties[name];
        return true;
    }
    /**
     * Returns an iterator providing the properties of the component.
     *
     * @param [options.filter] A function used to filter the properties to be returned. The function is invoked for each property with a [`Property`](https://layrjs.com/docs/v1/reference/property) instance as first argument.
     * @param [options.attributesOnly] A boolean specifying whether only attribute properties should be returned (default: `false`).
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     * @param [options.methodsOnly] A boolean specifying whether only method properties should be returned (default: `false`).
     *
     * @returns A [`Property`](https://layrjs.com/docs/v1/reference/property) instance iterator.
     *
     * @example
     * ```
     * for (const property of movie.getProperties()) {
     *   console.log(property.getName());
     * }
     *
     * // Should output:
     * // title
     * // play
     * ```
     *
     * @category Properties
     */
    static get getProperties() {
        return this.prototype.getProperties;
    }
    /**
     * Returns an iterator providing the properties of the component.
     *
     * @param [options.filter] A function used to filter the properties to be returned. The function is invoked for each property with a [`Property`](https://layrjs.com/docs/v1/reference/property) instance as first argument.
     * @param [options.attributesOnly] A boolean specifying whether only attribute properties should be returned (default: `false`).
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     * @param [options.methodsOnly] A boolean specifying whether only method properties should be returned (default: `false`).
     *
     * @returns A [`Property`](https://layrjs.com/docs/v1/reference/property) instance iterator.
     *
     * @example
     * ```
     * for (const property of movie.getProperties()) {
     *   console.log(property.getName());
     * }
     *
     * // Should output:
     * // title
     * // play
     * ```
     *
     * @category Properties
     */
    getProperties(options = {}) {
        const { filter: originalFilter, autoFork = true, attributesOnly = false, attributeSelector = true, setAttributesOnly = false, methodsOnly = false } = options;
        const component = this;
        const filter = createPropertyFilter(originalFilter, {
            attributesOnly,
            attributeSelector,
            setAttributesOnly,
            methodsOnly
        });
        return {
            *[Symbol.iterator]() {
                for (const name of component.getPropertyNames()) {
                    const property = component.getProperty(name, { autoFork });
                    if (filter.call(component, property)) {
                        yield property;
                    }
                }
            }
        };
    }
    /**
     * Returns the name of all the properties of the component.
     *
     * @returns An array of the property names.
     *
     * @example
     * ```
     * movie.getPropertyNames(); // => ['title', 'play']
     * ```
     *
     * @category Properties
     */
    static get getPropertyNames() {
        return this.prototype.getPropertyNames;
    }
    /**
     * Returns the name of all the properties of the component.
     *
     * @returns An array of the property names.
     *
     * @example
     * ```
     * movie.getPropertyNames(); // => ['title', 'play']
     * ```
     *
     * @category Properties
     */
    getPropertyNames() {
        const names = [];
        let currentObject = this;
        while ('__properties' in currentObject) {
            if (hasOwnProperty(currentObject, '__properties')) {
                const currentNames = Object.getOwnPropertyNames(currentObject.__properties);
                names.unshift(...currentNames);
            }
            currentObject = Object.getPrototypeOf(currentObject);
        }
        return Array.from(new Set(names));
    }
    static get __getProperties() {
        return this.prototype.__getProperties;
    }
    __getProperties({ autoCreateOrFork = true } = {}) {
        if (autoCreateOrFork) {
            if (!('__properties' in this)) {
                Object.defineProperty(this, '__properties', { value: Object.create(null) });
            }
            else if (!hasOwnProperty(this, '__properties')) {
                Object.defineProperty(this, '__properties', { value: Object.create(this.__properties) });
            }
        }
        return this.__properties;
    }
    // === Property exposure ===
    static normalizePropertyOperationSetting(setting, options = {}) {
        const { throwIfInvalid = true } = options;
        if (setting === true) {
            return true;
        }
        if (throwIfInvalid) {
            throw new Error(`The specified property operation setting (${JSON.stringify(setting)}) is invalid`);
        }
        return undefined;
    }
    static get resolvePropertyOperationSetting() {
        return this.prototype.resolvePropertyOperationSetting;
    }
    resolvePropertyOperationSetting(setting) {
        if (setting === true) {
            return true;
        }
        return undefined;
    }
    /**
     * Gets an attribute of the component.
     *
     * @param name The name of the attribute to get.
     *
     * @returns An instance of [`Attribute`](https://layrjs.com/docs/v1/reference/attribute).
     *
     * @example
     * ```
     * movie.getAttribute('title'); // => 'title' attribute property
     * movie.getAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    static get getAttribute() {
        return this.prototype.getAttribute;
    }
    /**
     * Gets an attribute of the component.
     *
     * @param name The name of the attribute to get.
     *
     * @returns An instance of [`Attribute`](https://layrjs.com/docs/v1/reference/attribute).
     *
     * @example
     * ```
     * movie.getAttribute('title'); // => 'title' attribute property
     * movie.getAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    getAttribute(name, options = {}) {
        const { autoFork = true } = options;
        const attribute = this.__getAttribute(name, { autoFork });
        if (attribute === undefined) {
            throw new Error(`The attribute '${name}' is missing (${this.describeComponent()})`);
        }
        return attribute;
    }
    /**
     * Returns whether the component has the specified attribute.
     *
     * @param name The name of the attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasAttribute('title'); // => true
     * movie.hasAttribute('name'); // => false
     * movie.hasAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    static get hasAttribute() {
        return this.prototype.hasAttribute;
    }
    /**
     * Returns whether the component has the specified attribute.
     *
     * @param name The name of the attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasAttribute('title'); // => true
     * movie.hasAttribute('name'); // => false
     * movie.hasAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    hasAttribute(name) {
        return this.__getAttribute(name, { autoFork: false }) !== undefined;
    }
    static get __getAttribute() {
        return this.prototype.__getAttribute;
    }
    __getAttribute(name, options) {
        const { autoFork } = options;
        const property = this.__getProperty(name, { autoFork });
        if (property === undefined) {
            return undefined;
        }
        if (!isAttributeInstance(property)) {
            throw new Error(`A property with the specified name was found, but it is not an attribute (${property.describe()})`);
        }
        return property;
    }
    /**
     * Defines an attribute in the component. Typically, instead of using this method, you would rather use the [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) decorator.
     *
     * @param name The name of the attribute to define.
     * @param [attributeOptions] The options to create the [`Attribute`](https://layrjs.com/docs/v1/reference/attribute#constructor).
     *
     * @returns The [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setAttribute('title', {valueType: 'string'});
     * ```
     *
     * @category Attribute Properties
     */
    static get setAttribute() {
        return this.prototype.setAttribute;
    }
    /**
     * Defines an attribute in the component. Typically, instead of using this method, you would rather use the [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) decorator.
     *
     * @param name The name of the attribute to define.
     * @param [attributeOptions] The options to create the [`Attribute`](https://layrjs.com/docs/v1/reference/attribute#constructor).
     *
     * @returns The [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setAttribute('title', {valueType: 'string'});
     * ```
     *
     * @category Attribute Properties
     */
    setAttribute(name, attributeOptions = {}) {
        return this.setProperty(name, Attribute, attributeOptions);
    }
    /**
     * Returns an iterator providing the attributes of the component.
     *
     * @param [options.filter] A function used to filter the attributes to be returned. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     *
     * @returns An [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance iterator.
     *
     * @example
     * ```
     * for (const attr of movie.getAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // title
     * ```
     *
     * @category Attribute Properties
     */
    static get getAttributes() {
        return this.prototype.getAttributes;
    }
    /**
     * Returns an iterator providing the attributes of the component.
     *
     * @param [options.filter] A function used to filter the attributes to be returned. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     *
     * @returns An [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance iterator.
     *
     * @example
     * ```
     * for (const attr of movie.getAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // title
     * ```
     *
     * @category Attribute Properties
     */
    getAttributes(options = {}) {
        const { filter, attributeSelector = true, setAttributesOnly = false, autoFork = true } = options;
        return this.getProperties({
            filter,
            autoFork,
            attributesOnly: true,
            attributeSelector,
            setAttributesOnly
        });
    }
    static get traverseAttributes() {
        return this.prototype.traverseAttributes;
    }
    traverseAttributes(iteratee, options = {}) {
        assertIsFunction(iteratee);
        const { attributeSelector = true, filter, setAttributesOnly = false, depth = Number.MAX_SAFE_INTEGER, includeReferencedComponents = false } = options;
        const resolvedAttributeSelector = this.resolveAttributeSelector(attributeSelector, {
            filter,
            setAttributesOnly,
            depth,
            includeReferencedComponents
        });
        this.__traverseAttributes(iteratee, {
            attributeSelector: resolvedAttributeSelector,
            setAttributesOnly
        });
    }
    static get __traverseAttributes() {
        return this.prototype.__traverseAttributes;
    }
    __traverseAttributes(iteratee, { attributeSelector, setAttributesOnly }) {
        for (const attribute of this.getAttributes({ attributeSelector })) {
            if (setAttributesOnly && !attribute.isSet()) {
                continue;
            }
            const name = attribute.getName();
            const subattributeSelector = getFromAttributeSelector(attributeSelector, name);
            if (subattributeSelector !== false) {
                iteratee(attribute);
            }
            attribute._traverseAttributes(iteratee, {
                attributeSelector: subattributeSelector,
                setAttributesOnly
            });
        }
    }
    // === Identifier attributes ===
    /**
     * Gets an identifier attribute of the component.
     *
     * @param name The name of the identifier attribute to get.
     *
     * @returns An instance of [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) or [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute).
     *
     * @example
     * ```
     * movie.getIdentifierAttribute('id'); // => 'id' primary identifier attribute
     * movie.getIdentifierAttribute('slug'); // => 'slug' secondary identifier attribute
     * ```
     *
     * @category Attribute Properties
     */
    getIdentifierAttribute(name, options = {}) {
        const { autoFork = true } = options;
        const identifierAttribute = this.__getIdentifierAttribute(name, { autoFork });
        if (identifierAttribute === undefined) {
            throw new Error(`The identifier attribute '${name}' is missing (${this.describeComponent()})`);
        }
        return identifierAttribute;
    }
    /**
     * Returns whether the component has the specified identifier attribute.
     *
     * @param name The name of the identifier attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasIdentifierAttribute('id'); // => true
     * movie.hasIdentifierAttribute('slug'); // => true
     * movie.hasIdentifierAttribute('name'); // => false (the property 'name' doesn't exist)
     * movie.hasIdentifierAttribute('title'); // => Error ('title' is not an identifier attribute)
     * ```
     *
     * @category Attribute Properties
     */
    hasIdentifierAttribute(name) {
        return this.__getIdentifierAttribute(name, { autoFork: false }) !== undefined;
    }
    __getIdentifierAttribute(name, options) {
        const { autoFork } = options;
        const property = this.__getProperty(name, { autoFork });
        if (property === undefined) {
            return undefined;
        }
        if (!isIdentifierAttributeInstance(property)) {
            throw new Error(`A property with the specified name was found, but it is not an identifier attribute (${property.describe()})`);
        }
        return property;
    }
    /**
     * Gets the primary identifier attribute of the component.
     *
     * @returns An instance of [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute).
     *
     * @example
     * ```
     * movie.getPrimaryIdentifierAttribute(); // => 'id' primary identifier attribute
     * ```
     *
     * @category Attribute Properties
     */
    getPrimaryIdentifierAttribute(options = {}) {
        const { autoFork = true } = options;
        const primaryIdentifierAttribute = this.__getPrimaryIdentifierAttribute({ autoFork });
        if (primaryIdentifierAttribute === undefined) {
            throw new Error(`The component '${this.constructor.getComponentName()}' doesn't have a primary identifier attribute`);
        }
        return primaryIdentifierAttribute;
    }
    /**
     * Returns whether the component as a primary identifier attribute.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasPrimaryIdentifierAttribute(); // => true
     * ```
     *
     * @category Attribute Properties
     */
    hasPrimaryIdentifierAttribute() {
        return this.__getPrimaryIdentifierAttribute({ autoFork: false }) !== undefined;
    }
    __getPrimaryIdentifierAttribute(options) {
        const { autoFork } = options;
        for (const identifierAttribute of this.getIdentifierAttributes({ autoFork })) {
            if (isPrimaryIdentifierAttributeInstance(identifierAttribute)) {
                return identifierAttribute;
            }
        }
        return undefined;
    }
    /**
     * Defines the primary identifier attribute of the component. Typically, instead of using this method, you would rather use the [`@primaryIdentifier()`](https://layrjs.com/docs/v1/reference/component#primary-identifier-decorator) decorator.
     *
     * @param name The name of the primary identifier attribute to define.
     * @param [attributeOptions] The options to create the [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute).
     *
     * @returns The [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) that was created.
     *
     * @example
     * ```
     * User.prototype.setPrimaryIdentifierAttribute('id', {
     *   valueType: 'number',
     *   default() {
     *     return Math.random();
     *   }
     * });
     * ```
     *
     * @category Attribute Properties
     */
    setPrimaryIdentifierAttribute(name, attributeOptions = {}) {
        return this.setProperty(name, PrimaryIdentifierAttribute, attributeOptions);
    }
    /**
     * Gets a secondary identifier attribute of the component.
     *
     * @param name The name of the secondary identifier attribute to get.
     *
     * @returns A [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) instance.
     *
     * @example
     * ```
     * movie.getSecondaryIdentifierAttribute('slug'); // => 'slug' secondary identifier attribute
     * movie.getSecondaryIdentifierAttribute('id'); // => Error ('id' is not a secondary identifier attribute)
     * ```
     *
     * @category Attribute Properties
     */
    getSecondaryIdentifierAttribute(name, options = {}) {
        const { autoFork = true } = options;
        const secondaryIdentifierAttribute = this.__getSecondaryIdentifierAttribute(name, { autoFork });
        if (secondaryIdentifierAttribute === undefined) {
            throw new Error(`The secondary identifier attribute '${name}' is missing (${this.describeComponent()})`);
        }
        return secondaryIdentifierAttribute;
    }
    /**
     * Returns whether the component has the specified secondary identifier attribute.
     *
     * @param name The name of the secondary identifier attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasSecondaryIdentifierAttribute('slug'); // => true
     * movie.hasSecondaryIdentifierAttribute('name'); // => false (the property 'name' doesn't exist)
     * movie.hasSecondaryIdentifierAttribute('id'); // => Error ('id' is not a secondary identifier attribute)
     * ```
     *
     * @category Attribute Properties
     */
    hasSecondaryIdentifierAttribute(name) {
        return this.__getSecondaryIdentifierAttribute(name, { autoFork: false }) !== undefined;
    }
    __getSecondaryIdentifierAttribute(name, options) {
        const { autoFork } = options;
        const property = this.__getProperty(name, { autoFork });
        if (property === undefined) {
            return undefined;
        }
        if (!isSecondaryIdentifierAttributeInstance(property)) {
            throw new Error(`A property with the specified name was found, but it is not a secondary identifier attribute (${property.describe()})`);
        }
        return property;
    }
    /**
     * Defines a secondary identifier attribute in the component. Typically, instead of using this method, you would rather use the [`@secondaryIdentifier()`](https://layrjs.com/docs/v1/reference/component#secondary-identifier-decorator) decorator.
     *
     * @param name The name of the secondary identifier attribute to define.
     * @param [attributeOptions] The options to create the [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute).
     *
     * @returns The [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) that was created.
     *
     * @example
     * ```
     * User.prototype.setSecondaryIdentifierAttribute('slug', {valueType: 'string'});
     * ```
     *
     * @category Attribute Properties
     */
    setSecondaryIdentifierAttribute(name, attributeOptions = {}) {
        return this.setProperty(name, SecondaryIdentifierAttribute, attributeOptions);
    }
    /**
     * Returns an iterator providing the identifier attributes of the component.
     *
     * @param [options.filter] A function used to filter the identifier attributes to be returned. The function is invoked for each identifier attribute with an `IdentifierAttribute` instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set identifier attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the identifier attributes to be returned (default: `true`, which means that all identifier attributes should be returned).
     *
     * @returns An iterator of [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) or [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute).
     *
     * @example
     * ```
     * for (const attr of movie.getIdentifierAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // id
     * // slug
     * ```
     *
     * @category Attribute Properties
     */
    getIdentifierAttributes(options = {}) {
        const { filter: originalFilter, attributeSelector = true, setAttributesOnly = false, autoFork = true } = options;
        const filter = function (property) {
            if (!isIdentifierAttributeInstance(property)) {
                return false;
            }
            if (originalFilter !== undefined) {
                return originalFilter.call(this, property);
            }
            return true;
        };
        return this.getProperties({
            filter,
            autoFork,
            attributeSelector,
            setAttributesOnly
        });
    }
    /**
     * Returns an iterator providing the secondary identifier attributes of the component.
     *
     * @param [options.filter] A function used to filter the secondary identifier attributes to be returned. The function is invoked for each identifier attribute with a [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set secondary identifier attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the secondary identifier attributes to be returned (default: `true`, which means that all secondary identifier attributes should be returned).
     *
     * @returns A [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) instance iterator.
     *
     * @example
     * ```
     * for (const attr of movie.getSecondaryIdentifierAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // slug
     * ```
     *
     * @category Attribute Properties
     */
    getSecondaryIdentifierAttributes(options = {}) {
        const { filter: originalFilter, attributeSelector = true, setAttributesOnly = false, autoFork = true } = options;
        const filter = function (property) {
            if (!isSecondaryIdentifierAttributeInstance(property)) {
                return false;
            }
            if (originalFilter !== undefined) {
                return originalFilter.call(this, property);
            }
            return true;
        };
        return this.getProperties({
            filter,
            autoFork,
            attributeSelector,
            setAttributesOnly
        });
    }
    /**
     * Returns an object composed of all the set identifiers of the component. The shape of the returned object is `{[identifierName]: identifierValue}`. If the component doesn't have any set identifiers, returns `undefined`.
     *
     * @returns An object.
     *
     * @example
     * ```
     * movie.getIdentifiers(); // => {id: 'abc123', slug: 'inception'}
     * ```
     *
     * @category Attribute Properties
     */
    getIdentifiers() {
        const identifiers = this.__getIdentifiers();
        if (identifiers === undefined) {
            throw new Error(`Cannot get the identifiers of a component that has no set identifier (${this.describeComponent()})`);
        }
        return identifiers;
    }
    /**
     * Returns whether the component has a set identifier or not.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasIdentifiers(); // => true
     * ```
     *
     * @category Attribute Properties
     */
    hasIdentifiers() {
        return this.__getIdentifiers() !== undefined;
    }
    __getIdentifiers() {
        let identifiers;
        for (const identifierAttribute of this.getIdentifierAttributes({
            setAttributesOnly: true,
            autoFork: false
        })) {
            const name = identifierAttribute.getName();
            const value = identifierAttribute.getValue();
            if (identifiers === undefined) {
                identifiers = {};
            }
            identifiers[name] = value;
        }
        return identifiers;
    }
    /**
     * Generates a unique identifier using the [cuid](https://github.com/ericelliott/cuid) library.
     *
     * @returns The generated identifier.
     *
     * @example
     * ```
     * Movie.generateId(); // => 'ck41vli1z00013h5xx1esffyn'
     * ```
     *
     * @category Attribute Properties
     */
    static generateId() {
        return cuid();
    }
    __partitionAttributes(object) {
        const identifierAttributes = {};
        const otherAttributes = {};
        const identifierAttributeSelector = createAttributeSelectorFromAttributes(this.getIdentifierAttributes());
        for (const [name, value] of Object.entries(object)) {
            if (getFromAttributeSelector(identifierAttributeSelector, name) === true) {
                identifierAttributes[name] = value;
            }
            else {
                otherAttributes[name] = value;
            }
        }
        return { identifierAttributes, otherAttributes };
    }
    __getMinimumAttributeCount() {
        return this.hasPrimaryIdentifierAttribute() ? 1 : 0;
    }
    // === Identifier Descriptor ===
    /**
     * Returns the `IdentifierDescriptor` of the component.
     *
     * An `IdentifierDescriptor` is a plain object composed of one pair of name/value corresponding to the name and value of the first identifier attribute encountered in a component. Usually it is the primary identifier, but if the latter is not set, it can be a secondary identifier.
     *
     * If there is no set identifier in the component, an error is thrown.
     *
     * @returns An object.
     *
     * @example
     * ```
     * movie.getIdentifierDescriptor(); // => {id: 'abc123'}
     * ```
     *
     * @category Identifier Descriptor
     */
    getIdentifierDescriptor() {
        const identifierDescriptor = this.__getIdentifierDescriptor();
        if (identifierDescriptor === undefined) {
            throw new Error(`Cannot get an identifier descriptor from a component that has no set identifier (${this.describeComponent()})`);
        }
        return identifierDescriptor;
    }
    /**
     * Returns whether the component can provide an `IdentifierDescriptor` (using the [`getIdentifierDescriptor()`](https://layrjs.com/docs/v1/reference/component#get-identifier-descriptor-instance-method) method) or not.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasIdentifierDescriptor(); // => true
     * ```
     *
     * @category Identifier Descriptor
     */
    hasIdentifierDescriptor() {
        return this.__getIdentifierDescriptor() !== undefined;
    }
    __getIdentifierDescriptor() {
        const primaryIdentifierAttribute = this.getPrimaryIdentifierAttribute();
        if (primaryIdentifierAttribute.isSet()) {
            const name = primaryIdentifierAttribute.getName();
            const value = primaryIdentifierAttribute.getValue();
            return { [name]: value };
        }
        for (const secondaryIdentifierAttribute of this.getSecondaryIdentifierAttributes({
            setAttributesOnly: true
        })) {
            const name = secondaryIdentifierAttribute.getName();
            const value = secondaryIdentifierAttribute.getValue();
            return { [name]: value };
        }
        return undefined;
    }
    static normalizeIdentifierDescriptor(identifierDescriptor) {
        if (typeof identifierDescriptor === 'string' || typeof identifierDescriptor === 'number') {
            const primaryIdentifierAttribute = this.prototype.getPrimaryIdentifierAttribute();
            const name = primaryIdentifierAttribute.getName();
            primaryIdentifierAttribute.checkValue(identifierDescriptor);
            return { [name]: identifierDescriptor };
        }
        if (!isPlainObject(identifierDescriptor)) {
            throw new Error(`An identifier descriptor should be a string, a number, or an object, but received a value of type '${getTypeOf(identifierDescriptor)}' (${this.describeComponent()})`);
        }
        const attributes = Object.entries(identifierDescriptor);
        if (attributes.length !== 1) {
            throw new Error(`An identifier descriptor should be a string, a number, or an object composed of one attribute, but received an object composed of ${attributes.length} attributes (${this.describeComponent()}, received object: ${JSON.stringify(identifierDescriptor)})`);
        }
        const [name, value] = attributes[0];
        const identifierAttribute = this.prototype.getIdentifierAttribute(name);
        identifierAttribute.checkValue(value);
        return { [name]: value };
    }
    static describeIdentifierDescriptor(identifierDescriptor) {
        const normalizedIdentifierDescriptor = this.normalizeIdentifierDescriptor(identifierDescriptor);
        const [[name, value]] = Object.entries(normalizedIdentifierDescriptor);
        const valueString = typeof value === 'string' ? `'${value}'` : value.toString();
        return `${name}: ${valueString}`;
    }
    /**
     * Gets the [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map) of the component.
     *
     * @returns An [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map) instance.
     *
     * @category Identity Mapping
     */
    static getIdentityMap() {
        if (this.__identityMap === undefined) {
            Object.defineProperty(this, '__identityMap', { value: new IdentityMap(this) });
        }
        else if (!hasOwnProperty(this, '__identityMap')) {
            Object.defineProperty(this, '__identityMap', { value: this.__identityMap.fork(this) });
        }
        return this.__identityMap;
    }
    /**
     * Attaches the component class to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map). By default, all component classes are attached, so unless you have detached a component class earlier, you should not have to use this method.
     *
     * @returns The component class.
     *
     * @category Identity Mapping
     */
    static attach() {
        Object.defineProperty(this, '__isAttached', { value: true, configurable: true });
        return this;
    }
    /**
     * Detaches the component class from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns The component class.
     *
     * @category Identity Mapping
     */
    static detach() {
        Object.defineProperty(this, '__isAttached', { value: false, configurable: true });
        return this;
    }
    /**
     * Returns whether the component class is attached to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    static isAttached() {
        let currentComponent = this;
        while (true) {
            const isAttached = currentComponent.__isAttached;
            if (isAttached !== undefined) {
                return isAttached;
            }
            const componentProvider = currentComponent.getComponentProvider();
            if (componentProvider === currentComponent) {
                return true;
            }
            currentComponent = componentProvider;
        }
    }
    /**
     * Returns whether the component class is detached from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    static isDetached() {
        return !this.isAttached();
    }
    /**
     * Attaches the component instance to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map). By default, all component instances are attached, so unless you have detached a component instance earlier, you should not have to use this method.
     *
     * @returns The component instance.
     *
     * @category Identity Mapping
     */
    attach() {
        Object.defineProperty(this, '__isAttached', { value: true, configurable: true });
        if (this.hasPrimaryIdentifierAttribute()) {
            const identityMap = this.constructor.getIdentityMap();
            identityMap.addComponent(this);
        }
        return this;
    }
    /**
     * Detaches the component instance from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns The component instance.
     *
     * @category Identity Mapping
     */
    detach() {
        if (this.hasPrimaryIdentifierAttribute()) {
            const identityMap = this.constructor.getIdentityMap();
            identityMap.removeComponent(this);
        }
        Object.defineProperty(this, '__isAttached', { value: false, configurable: true });
        return this;
    }
    /**
     * Returns whether the component instance is attached to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    isAttached() {
        if (this.__isAttached !== undefined) {
            return this.__isAttached;
        }
        return this.constructor.isAttached();
    }
    /**
     * Returns whether the component instance is detached from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    isDetached() {
        return !this.isAttached();
    }
    // === Attribute selectors ===
    static get resolveAttributeSelector() {
        return this.prototype.resolveAttributeSelector;
    }
    resolveAttributeSelector(attributeSelector, options = {}) {
        attributeSelector = normalizeAttributeSelector(attributeSelector);
        const { filter, setAttributesOnly = false, target, aggregationMode = 'union', includeReferencedComponents = false, alwaysIncludePrimaryIdentifierAttributes = true, allowPartialArrayItems = true, depth = Number.MAX_SAFE_INTEGER, _isDeep = false, _isArrayItem = false, _attributeStack = new Set() } = options;
        const _skipUnchangedAttributes = setAttributesOnly &&
            target !== undefined &&
            (target === -1 || typeof this.isStorable === 'function');
        return this.__resolveAttributeSelector(attributeSelector, {
            filter,
            setAttributesOnly,
            target,
            aggregationMode,
            includeReferencedComponents,
            alwaysIncludePrimaryIdentifierAttributes,
            allowPartialArrayItems,
            depth,
            _isDeep,
            _skipUnchangedAttributes,
            _isArrayItem,
            _attributeStack
        });
    }
    static get __resolveAttributeSelector() {
        return this.prototype.__resolveAttributeSelector;
    }
    __resolveAttributeSelector(attributeSelector, options) {
        const { filter, setAttributesOnly, target, includeReferencedComponents, alwaysIncludePrimaryIdentifierAttributes, allowPartialArrayItems, depth, _isDeep, _skipUnchangedAttributes, _isArrayItem, _attributeStack } = options;
        if (depth < 0) {
            return attributeSelector;
        }
        const newDepth = depth - 1;
        let resolvedAttributeSelector = {};
        if (attributeSelector === false) {
            return resolvedAttributeSelector; // Optimization
        }
        const isEmbedded = isComponentInstance(this) && this.constructor.isEmbedded();
        if (!setAttributesOnly && isEmbedded && _isArrayItem && !allowPartialArrayItems) {
            attributeSelector = true;
        }
        // By default, referenced components are not resolved
        if (!_isDeep || includeReferencedComponents || isEmbedded) {
            for (const attribute of this.getAttributes({ filter, setAttributesOnly })) {
                const name = attribute.getName();
                const subattributeSelector = getFromAttributeSelector(attributeSelector, name);
                if (subattributeSelector === false) {
                    continue;
                }
                if (_skipUnchangedAttributes && attribute.getValueSource() === target) {
                    continue;
                }
                if (_attributeStack.has(attribute)) {
                    continue; // Avoid looping indefinitely when a circular attribute is encountered
                }
                _attributeStack.add(attribute);
                const resolvedSubattributeSelector = attribute._resolveAttributeSelector(subattributeSelector, { ...options, depth: newDepth, _isDeep: true });
                _attributeStack.delete(attribute);
                if (resolvedSubattributeSelector !== false) {
                    resolvedAttributeSelector = setWithinAttributeSelector(resolvedAttributeSelector, name, resolvedSubattributeSelector);
                }
            }
        }
        if (isComponentInstance(this) &&
            alwaysIncludePrimaryIdentifierAttributes &&
            this.hasPrimaryIdentifierAttribute()) {
            const primaryIdentifierAttribute = this.getPrimaryIdentifierAttribute();
            const isNotFilteredOut = filter !== undefined ? filter.call(this, primaryIdentifierAttribute) : true;
            if (isNotFilteredOut && (!setAttributesOnly || primaryIdentifierAttribute.isSet())) {
                resolvedAttributeSelector = setWithinAttributeSelector(resolvedAttributeSelector, primaryIdentifierAttribute.getName(), true);
            }
        }
        return resolvedAttributeSelector;
    }
    // === Validation ===
    /**
     * Validates the attributes of the component. If an attribute doesn't pass the validation, an error is thrown. The error is a JavaScript `Error` instance with a `failedValidators` custom attribute which contains the result of the [`runValidators()`](https://layrjs.com/docs/v1/reference/component#run-validators-dual-method) method.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @example
     * ```
     * // JS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title!: string;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @category Validation
     */
    static get validate() {
        return this.prototype.validate;
    }
    /**
     * Validates the attributes of the component. If an attribute doesn't pass the validation, an error is thrown. The error is a JavaScript `Error` instance with a `failedValidators` custom attribute which contains the result of the [`runValidators()`](https://layrjs.com/docs/v1/reference/component#run-validators-dual-method) method.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @example
     * ```
     * // JS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title!: string;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @category Validation
     */
    validate(attributeSelector = true) {
        const failedValidators = this.runValidators(attributeSelector);
        if (failedValidators.length === 0) {
            return;
        }
        const details = failedValidators
            .map(({ validator, path }) => `${validator.getMessage()} (path: '${path}')`)
            .join(', ');
        const error = Object.assign(new Error(`The following error(s) occurred while validating the component '${ensureComponentClass(this).getComponentName()}': ${details}`), { failedValidators });
        throw error;
    }
    /**
     * Returns whether the attributes of the component are valid.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be checked (default: `true`, which means that all the attributes will be checked).
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.isValid(); // => true
     * movie.title = '';
     * movie.isValid(); // => false
     * ```
     *
     * @category Validation
     */
    static get isValid() {
        return this.prototype.isValid;
    }
    /**
     * Returns whether the attributes of the component are valid.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be checked (default: `true`, which means that all the attributes will be checked).
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.isValid(); // => true
     * movie.title = '';
     * movie.isValid(); // => false
     * ```
     *
     * @category Validation
     */
    isValid(attributeSelector = true) {
        const failedValidators = this.runValidators(attributeSelector);
        return failedValidators.length === 0;
    }
    /**
     * Runs the validators for all the set attributes of the component.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @returns An array containing the validators that have failed. Each item is a plain object composed of a `validator` (a [`Validator`](https://layrjs.com/docs/v1/reference/validator) instance) and a `path` (a string representing the path of the attribute containing the validator that has failed).
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.runValidators(); // => []
     * movie.title = '';
     * movie.runValidators(); // => [{validator: ..., path: 'title'}]
     * ```
     *
     * @category Validation
     */
    static get runValidators() {
        return this.prototype.runValidators;
    }
    /**
     * Runs the validators for all the set attributes of the component.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @returns An array containing the validators that have failed. Each item is a plain object composed of a `validator` (a [`Validator`](https://layrjs.com/docs/v1/reference/validator) instance) and a `path` (a string representing the path of the attribute containing the validator that has failed).
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.runValidators(); // => []
     * movie.title = '';
     * movie.runValidators(); // => [{validator: ..., path: 'title'}]
     * ```
     *
     * @category Validation
     */
    runValidators(attributeSelector = true) {
        attributeSelector = this.resolveAttributeSelector(attributeSelector);
        const failedValidators = [];
        for (const attribute of this.getAttributes({ setAttributesOnly: true })) {
            const name = attribute.getName();
            const subattributeSelector = getFromAttributeSelector(attributeSelector, name);
            if (subattributeSelector === false) {
                continue;
            }
            const attributeFailedValidators = attribute.runValidators(subattributeSelector);
            for (const { validator, path } of attributeFailedValidators) {
                failedValidators.push({ validator, path: joinAttributePath([name, path]) });
            }
        }
        return failedValidators;
    }
    // === Method Properties ===
    /**
     * Gets a method of the component.
     *
     * @param name The name of the method to get.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance.
     *
     * @example
     * ```
     * movie.getMethod('play'); // => 'play' method property
     * movie.getMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    static get getMethod() {
        return this.prototype.getMethod;
    }
    /**
     * Gets a method of the component.
     *
     * @param name The name of the method to get.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance.
     *
     * @example
     * ```
     * movie.getMethod('play'); // => 'play' method property
     * movie.getMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    getMethod(name, options = {}) {
        const { autoFork = true } = options;
        const method = this.__getMethod(name, { autoFork });
        if (method === undefined) {
            throw new Error(`The method '${name}' is missing (${this.describeComponent()})`);
        }
        return method;
    }
    /**
     * Returns whether the component has the specified method.
     *
     * @param name The name of the method to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasMethod('play'); // => true
     * movie.hasMethod('destroy'); // => false
     * movie.hasMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    static get hasMethod() {
        return this.prototype.hasMethod;
    }
    /**
     * Returns whether the component has the specified method.
     *
     * @param name The name of the method to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasMethod('play'); // => true
     * movie.hasMethod('destroy'); // => false
     * movie.hasMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    hasMethod(name) {
        return this.__getMethod(name, { autoFork: false }) !== undefined;
    }
    static get __getMethod() {
        return this.prototype.__getMethod;
    }
    __getMethod(name, options) {
        const { autoFork } = options;
        const property = this.__getProperty(name, { autoFork });
        if (property === undefined) {
            return undefined;
        }
        if (!isMethodInstance(property)) {
            throw new Error(`A property with the specified name was found, but it is not a method (${property.describe()})`);
        }
        return property;
    }
    /**
     * Defines a method in the component. Typically, instead of using this method, you would rather use the [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator) decorator.
     *
     * @param name The name of the method to define.
     * @param [methodOptions] The options to create the [`Method`](https://layrjs.com/docs/v1/reference/method#constructor).
     *
     * @returns The [`Method`](https://layrjs.com/docs/v1/reference/method) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setMethod('play');
     * ```
     *
     * @category Method Properties
     */
    static get setMethod() {
        return this.prototype.setMethod;
    }
    /**
     * Defines a method in the component. Typically, instead of using this method, you would rather use the [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator) decorator.
     *
     * @param name The name of the method to define.
     * @param [methodOptions] The options to create the [`Method`](https://layrjs.com/docs/v1/reference/method#constructor).
     *
     * @returns The [`Method`](https://layrjs.com/docs/v1/reference/method) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setMethod('play');
     * ```
     *
     * @category Method Properties
     */
    setMethod(name, methodOptions = {}) {
        return this.setProperty(name, Method, methodOptions);
    }
    /**
     * Returns an iterator providing the methods of the component.
     *
     * @param [options.filter] A function used to filter the methods to be returned. The function is invoked for each method with a [`Method`](https://layrjs.com/docs/v1/reference/method) instance as first argument.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance iterator.
     *
     * @example
     * ```
     * for (const meth of movie.getMethods()) {
     *   console.log(meth.getName());
     * }
     *
     * // Should output:
     * // play
     * ```
     *
     * @category Method Properties
     */
    static get getMethods() {
        return this.prototype.getMethods;
    }
    /**
     * Returns an iterator providing the methods of the component.
     *
     * @param [options.filter] A function used to filter the methods to be returned. The function is invoked for each method with a [`Method`](https://layrjs.com/docs/v1/reference/method) instance as first argument.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance iterator.
     *
     * @example
     * ```
     * for (const meth of movie.getMethods()) {
     *   console.log(meth.getName());
     * }
     *
     * // Should output:
     * // play
     * ```
     *
     * @category Method Properties
     */
    getMethods(options = {}) {
        const { filter, autoFork = true } = options;
        return this.getProperties({ filter, autoFork, methodsOnly: true });
    }
    // === Dependency Management ===
    // --- Component getters ---
    /**
     * Gets a component class that is provided or consumed by the current component. An error is thrown if there is no component matching the specified name. If the specified name is the name of the current component, the latter is returned.
     *
     * @param name The name of the component class to get.
     *
     * @returns A component class.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.getComponent('Movie'); // => Movie
     * Backend.getComponent('Backend'); // => Backend
     * ```
     *
     * @category Dependency Management
     */
    static getComponent(name) {
        const component = this.__getComponent(name);
        if (component === undefined) {
            throw new Error(`Cannot get the component '${name}' from the component '${this.getComponentPath()}'`);
        }
        return component;
    }
    /**
     * Returns whether the current component provides or consumes another component.
     *
     * @param name The name of the component class to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.hasComponent('Movie'); // => true
     * Backend.hasComponent('Backend'); // => true
     * Backend.hasComponent('Film'); // => false
     * ```
     *
     * @category Dependency Management
     */
    static hasComponent(name) {
        return this.__getComponent(name) !== undefined;
    }
    static __getComponent(name) {
        assertIsComponentName(name);
        if (this.getComponentName() === name) {
            return this;
        }
        let providedComponent = this.getProvidedComponent(name);
        if (providedComponent !== undefined) {
            return providedComponent;
        }
        const componentProvider = this.__getComponentProvider();
        if (componentProvider !== undefined) {
            return componentProvider.__getComponent(name);
        }
        return undefined;
    }
    /**
     * Gets a component class or prototype of the specified type that is provided or consumed by the current component. An error is thrown if there is no component matching the specified type. If the specified type is the type of the current component, the latter is returned.
     *
     * @param type The type of the component class or prototype to get.
     *
     * @returns A component class or prototype.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.getComponentOfType('typeof Movie'); // => Movie
     * Backend.getComponentOfType('Movie'); // => Movie.prototype
     * Backend.getComponentOfType('typeof Backend'); // => Backend
     * Backend.getComponentOfType('Backend'); // => Backend.prototype
     * ```
     *
     * @category Dependency Management
     */
    static getComponentOfType(type) {
        const component = this.__getComponentOfType(type);
        if (component === undefined) {
            throw new Error(`Cannot get the component of type '${type}' from the component '${this.getComponentPath()}'`);
        }
        return component;
    }
    /**
     * Returns whether the current component provides or consumes a component class or prototype matching the specified type.
     *
     * @param type The type of the component class or prototype to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.hasComponentOfType('typeof Movie'); // => true
     * Backend.hasComponentOfType('Movie'); // => true
     * Backend.hasComponentOfType('typeof Backend'); // => true
     * Backend.hasComponentOfType('Backend'); // => true
     * Backend.hasComponentOfType('typeof Film'); // => false
     * Backend.hasComponentOfType('Film'); // => false
     * ```
     *
     * @category Dependency Management
     */
    static hasComponentOfType(type) {
        return this.__getComponentOfType(type) !== undefined;
    }
    static __getComponentOfType(type) {
        const isComponentClassType = assertIsComponentType(type) === 'componentClassType';
        const componentName = isComponentClassType
            ? getComponentNameFromComponentClassType(type)
            : getComponentNameFromComponentInstanceType(type);
        const component = this.__getComponent(componentName);
        if (component === undefined) {
            return undefined;
        }
        return isComponentClassType ? component : component.prototype;
    }
    // --- Component provision ---
    /**
     * Gets a component that is provided by the current component. An error is thrown if there is no provided component with the specified name.
     *
     * @param name The name of the provided component to get.
     *
     * @returns A component class.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.getProvidedComponent('Movie'); // => Movie
     * ```
     *
     * @category Dependency Management
     */
    static getProvidedComponent(name) {
        assertIsComponentName(name);
        const providedComponents = this.__getProvidedComponents();
        let providedComponent = providedComponents[name];
        if (providedComponent === undefined) {
            return undefined;
        }
        if (!hasOwnProperty(providedComponents, name)) {
            // Since the host component has been forked, the provided component must be forked as well
            providedComponent = providedComponent.fork({ componentProvider: this });
            providedComponents[name] = providedComponent;
        }
        return providedComponent;
    }
    /**
     * Specifies that the current component is providing another component so it can be easily accessed from the current component or from any component that is "consuming" it using the [`consumeComponent()`](https://layrjs.com/docs/v1/reference/component#consume-component-class-method) method or the [`@consume()`](https://layrjs.com/docs/v1/reference/component#consume-decorator) decorator.
     *
     * The provided component can later be accessed using a component accessor that was automatically set on the component provider.
     *
     * Typically, instead of using this method, you would rather use the [`@provide()`]((https://layrjs.com/docs/v1/reference/component#provide-decorator)) decorator.
     *
     * @param component The component class to provide.
     *
     * @example
     * ```
     * class Backend extends Component {}
     * class Movie extends Component {}
     * Backend.provideComponent(Movie);
     *
     * Backend.Movie; // => `Movie` class
     * ```
     *
     * @category Dependency Management
     */
    static provideComponent(component) {
        assertIsComponentClass(component);
        const providedComponents = this.__getProvidedComponents();
        const existingProvider = component.__getComponentProvider();
        if (existingProvider !== undefined) {
            if (existingProvider === this) {
                return;
            }
            throw new Error(`Cannot provide the component '${component.getComponentName()}' from '${this.getComponentName()}' because '${component.getComponentName()}' is already provided by '${existingProvider.getComponentName()}'`);
        }
        const componentName = component.getComponentName();
        const existingComponent = providedComponents[componentName];
        if (existingComponent !== undefined && !component.isForkOf(existingComponent)) {
            throw new Error(`Cannot provide the component '${component.getComponentName()}' from '${this.getComponentName()}' because a component with the same name is already provided`);
        }
        if (componentName in this) {
            const descriptor = Object.getOwnPropertyDescriptor(this, componentName);
            const value = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;
            if (!(isComponentClass(value) && (value === component || value.isForkOf(component)))) {
                throw new Error(`Cannot provide the component '${component.getComponentName()}' from '${this.getComponentName()}' because there is an existing property with the same name`);
            }
        }
        component.__setComponentProvider(this);
        providedComponents[componentName] = component;
        Object.defineProperty(this, componentName, {
            get() {
                return this.getProvidedComponent(componentName);
            },
            set(component) {
                // Set the value temporarily so @provide() can get it
                Object.defineProperty(this, componentName, {
                    value: component,
                    configurable: true,
                    enumerable: true,
                    writable: true
                });
            }
        });
    }
    /**
     * Returns an iterator allowing to iterate over the components provided by the current component.
     *
     * @param [options.filter] A function used to filter the provided components to be returned. The function is invoked for each provided component with the provided component as first argument.
     * @param [options.deep] A boolean specifying whether the method should get the provided components recursively (i.e., get the provided components of the provided components). Default: `false`.
     *
     * @returns A component iterator.
     *
     * @category Dependency Management
     */
    static getProvidedComponents(options = {}) {
        const { deep = false, filter } = options;
        const component = this;
        return {
            *[Symbol.iterator]() {
                for (const name in component.__getProvidedComponents()) {
                    const providedComponent = component.getProvidedComponent(name);
                    if (filter !== undefined && !filter(providedComponent)) {
                        continue;
                    }
                    yield providedComponent;
                    if (deep) {
                        for (const nestedProvidedComponent of providedComponent.getProvidedComponents({
                            deep,
                            filter
                        })) {
                            yield nestedProvidedComponent;
                        }
                    }
                }
            }
        };
    }
    /**
     * Returns the provider of the component. If there is no component provider, returns the current component.
     *
     * @returns A component provider.
     *
     * @example
     * ```
     * class Backend extends Component {}
     * class Movie extends Component {}
     * Backend.provideComponent(Movie);
     *
     * Movie.getComponentProvider(); // => `Backend` class
     * Backend.getComponentProvider(); // => `Backend` class
     * ```
     *
     * @category Dependency Management
     */
    static getComponentProvider() {
        const componentName = this.getComponentName();
        let currentComponent = this;
        while (true) {
            const componentProvider = currentComponent.__getComponentProvider();
            if (componentProvider === undefined) {
                return currentComponent;
            }
            const providedComponent = componentProvider.getProvidedComponent(componentName);
            if (providedComponent !== undefined) {
                return componentProvider;
            }
            currentComponent = componentProvider;
        }
    }
    static __getComponentProvider() {
        return hasOwnProperty(this, '__componentProvider') ? this.__componentProvider : undefined;
    }
    static __setComponentProvider(componentProvider) {
        Object.defineProperty(this, '__componentProvider', { value: componentProvider });
    }
    static __getProvidedComponents() {
        if (this.__providedComponents === undefined) {
            Object.defineProperty(this, '__providedComponents', {
                value: Object.create(null)
            });
        }
        else if (!hasOwnProperty(this, '__providedComponents')) {
            Object.defineProperty(this, '__providedComponents', {
                value: Object.create(this.__providedComponents)
            });
        }
        return this.__providedComponents;
    }
    // --- Component consumption ---
    /**
     * Gets a component that is consumed by the current component. An error is thrown if there is no consumed component with the specified name. Typically, instead of using this method, you would rather use the component accessor that has been automatically set for you.
     *
     * @param name The name of the consumed component to get.
     *
     * @returns A component class.
     *
     * @example
     * ```
     * // JS
     *
     * class Movie extends Component {
     *   ﹫consume() static Actor;
     * }
     *
     * class Actor extends Component {}
     *
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     *   ﹫provide() static Actor = Actor;
     * }
     *
     * Movie.getConsumedComponent('Actor'); // => Actor
     *
     * // Typically, you would rather use the component accessor:
     * Movie.Actor; // => Actor
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * class Movie extends Component {
     *   ﹫consume() static Actor: typeof Actor;
     * }
     *
     * class Actor extends Component {}
     *
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     *   ﹫provide() static Actor = Actor;
     * }
     *
     * Movie.getConsumedComponent('Actor'); // => Actor
     *
     * // Typically, you would rather use the component accessor:
     * Movie.Actor; // => Actor
     * ```
     *
     * @category Dependency Management
     */
    static getConsumedComponent(name) {
        assertIsComponentName(name);
        const consumedComponents = this.__getConsumedComponents();
        if (!consumedComponents.has(name)) {
            return undefined;
        }
        const componentProvider = this.__getComponentProvider();
        if (componentProvider === undefined) {
            return undefined;
        }
        return componentProvider.__getComponent(name);
    }
    /**
     * Specifies that the current component is consuming another component so it can be easily accessed using a component accessor.
     *
     * Typically, instead of using this method, you would rather use the [`@consume()`]((https://layrjs.com/docs/v1/reference/component#consume-decorator)) decorator.
     *
     * @param name The name of the component to consume.
     *
     * @example
     * ```
     * class Backend extends Component {}
     * class Movie extends Component {}
     * Backend.provideComponent(Movie);
     * Movie.consumeComponent('Backend');
     *
     * Movie.Backend; // => `Backend` class
     * ```
     *
     * @category Dependency Management
     */
    static consumeComponent(name) {
        assertIsComponentName(name);
        const consumedComponents = this.__getConsumedComponents(true);
        if (consumedComponents.has(name)) {
            return;
        }
        if (name in this) {
            throw new Error(`Cannot consume the component '${name}' from '${this.getComponentName()}' because there is an existing property with the same name`);
        }
        consumedComponents.add(name);
        Object.defineProperty(this, name, {
            get() {
                return this.getConsumedComponent(name);
            },
            set(_value) {
                // A component consumer should not be set directly
            }
        });
    }
    /**
     * Returns an iterator allowing to iterate over the components consumed by the current component.
     *
     * @param [options.filter] A function used to filter the consumed components to be returned. The function is invoked for each consumed component with the consumed component as first argument.
     *
     * @returns A component iterator.
     *
     * @category Dependency Management
     */
    static getConsumedComponents(options = {}) {
        const { filter } = options;
        const component = this;
        return {
            *[Symbol.iterator]() {
                for (const name of component.__getConsumedComponents()) {
                    const consumedComponent = component.getConsumedComponent(name);
                    if (filter !== undefined && !filter(consumedComponent)) {
                        continue;
                    }
                    yield consumedComponent;
                }
            }
        };
    }
    static __getConsumedComponents(autoFork = false) {
        if (this.__consumedComponents === undefined) {
            Object.defineProperty(this, '__consumedComponents', {
                value: new Set()
            });
        }
        else if (autoFork && !hasOwnProperty(this, '__consumedComponents')) {
            Object.defineProperty(this, '__consumedComponents', {
                value: new Set(this.__consumedComponents)
            });
        }
        return this.__consumedComponents;
    }
    // === Cloning ===
    static clone() {
        return this;
    }
    clone(options = {}) {
        if (this.hasPrimaryIdentifierAttribute()) {
            return this;
        }
        const clonedComponent = this.constructor.create({}, {
            isNew: this.getIsNewMark(),
            source: this.getIsNewMarkSource(),
            attributeSelector: {},
            initialize: false
        });
        for (const attribute of this.getAttributes({ setAttributesOnly: true })) {
            const name = attribute.getName();
            const value = attribute.getValue();
            const source = attribute.getValueSource();
            const clonedValue = clone(value, options);
            clonedComponent.getAttribute(name).setValue(clonedValue, { source });
        }
        return possiblyAsync(clonedComponent.initialize(), () => clonedComponent);
    }
    // === Forking ===
    /**
     * Creates a fork of the component class.
     *
     * @returns The component class fork.
     *
     * @example
     * ```
     * class Movie extends Component {}
     *
     * Movie.fork(); // => A fork of the `Movie` class
     * ```
     *
     * @category Forking
     */
    static fork(options = {}) {
        const { componentProvider = this.__getComponentProvider() } = options;
        const name = this.getComponentName();
        // Use a little trick to make sure the generated subclass
        // has the 'name' attribute set properly
        // @ts-ignore
        const { [name]: forkedComponent } = { [name]: class extends this {
            } };
        if (forkedComponent.name !== name) {
            // In case the code has been transpiled by Babel with @babel/plugin-transform-classes,
            // the above trick doesn't work, so let's set the class name manually
            Object.defineProperty(forkedComponent, 'name', { value: name });
        }
        if (componentProvider !== undefined) {
            forkedComponent.__setComponentProvider(componentProvider);
        }
        return forkedComponent;
    }
    /**
     * Creates a fork of the component instance. Note that the constructor of the resulting component will be a fork of the component class.
     *
     * @returns The component instance fork.
     *
     * @example
     * ```
     * class Movie extends Component {}
     * const movie = new Movie();
     *
     * movie.fork(); // => A fork of `movie`
     * movie.fork().constructor.isForkOf(Movie); // => true
     * ```
     *
     * @category Forking
     */
    fork(options = {}) {
        let { componentClass } = options;
        if (componentClass === undefined) {
            componentClass = this.constructor.fork();
        }
        else {
            assertIsComponentClass(componentClass);
        }
        const forkedComponent = Object.create(this);
        if (this.constructor !== componentClass) {
            // Make 'forkedComponent' believe that it is an instance of 'Component'
            // It can happen when a referenced component is forked
            Object.defineProperty(forkedComponent, 'constructor', {
                value: componentClass,
                writable: true,
                enumerable: false,
                configurable: true
            });
            if (forkedComponent.hasPrimaryIdentifierAttribute() && forkedComponent.isAttached()) {
                componentClass.getIdentityMap().addComponent(forkedComponent);
            }
        }
        return forkedComponent;
    }
    /**
     * Returns whether the component class is a fork of another component class.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Movie extends Component {}
     * const MovieFork = Movie.fork();
     *
     * MovieFork.isForkOf(Movie); // => true
     * Movie.isForkOf(MovieFork); // => false
     * ```
     *
     * @category Forking
     */
    static isForkOf(component) {
        assertIsComponentClass(component);
        return isPrototypeOf(component, this);
    }
    /**
     * Returns whether the component instance is a fork of another component instance.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Movie extends Component {}
     * const movie = new Movie();
     * const movieFork = movie.fork();
     *
     * movieFork.isForkOf(movie); // => true
     * movie.isForkOf(movieFork); // => false
     * ```
     *
     * @category Forking
     */
    isForkOf(component) {
        assertIsComponentInstance(component);
        return isPrototypeOf(component, this);
    }
    static [Symbol.hasInstance](instance) {
        // Since fork() can change the constructor of the forked instances,
        // we must change the behavior of 'instanceof' so it can work as expected
        return instance.constructor === this || isPrototypeOf(this, instance.constructor);
    }
    /**
     * Gets the ghost of the component class. A ghost is like a fork, but it is unique. The first time you call this method, a fork is created, and then, all the successive calls return the same fork.
     *
     * @returns The ghost of the component class.
     *
     * @example
     * ```
     * class Movie extends Component {}
     *
     * Movie.getGhost() // => A fork of the `Movie` class
     * Movie.getGhost() // => The same fork of the `Movie` class
     * ```
     *
     * @category Forking
     */
    static getGhost() {
        let ghost = this.__ghost;
        if (ghost === undefined) {
            const componentProvider = this.getComponentProvider();
            if (componentProvider === this) {
                ghost = this.fork();
            }
            else {
                ghost = componentProvider.getGhost().getComponent(this.getComponentName());
            }
            Object.defineProperty(this, '__ghost', { value: ghost });
        }
        return ghost;
    }
    /**
     * Gets the ghost of the component instance. A ghost is like a fork, but it is unique. The first time you call this method, a fork is created, and then, all the successive calls return the same fork. Only identifiable components (i.e., components having an identifier attribute) can be "ghosted".
     *
     * @returns The ghost of the component instance.
     *
     * @example
     * ```
     * // JS
     *
     * class Movie extends Component {
     *   ﹫primaryIdentifier() id;
     * }
     *
     * const movie = new Movie();
     *
     * movie.getGhost() // => A fork of `movie`
     * movie.getGhost() // => The same fork of `movie`
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * class Movie extends Component {
     *   ﹫primaryIdentifier() id!: string;
     * }
     *
     * const movie = new Movie();
     *
     * movie.getGhost() // => A fork of `movie`
     * movie.getGhost() // => The same fork of `movie`
     * ```
     *
     * @category Forking
     */
    getGhost() {
        const identifiers = this.getIdentifiers();
        const ghostClass = this.constructor.getGhost();
        const ghostIdentityMap = ghostClass.getIdentityMap();
        let ghostComponent = ghostIdentityMap.getComponent(identifiers);
        if (ghostComponent === undefined) {
            ghostComponent = this.fork({ componentClass: ghostClass });
            ghostIdentityMap.addComponent(ghostComponent);
        }
        return ghostComponent;
    }
    // === Merging ===
    /**
     * Merges the attributes of a component class fork into the current component class.
     *
     * @param forkedComponent The component class fork to merge.
     *
     * @returns The current component class.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') static customName = 'Movie';
     * }
     *
     * const MovieFork = Movie.fork();
     * MovieFork.customName = 'Film';
     *
     * Movie.customName; // => 'Movie'
     * Movie.merge(MovieFork);
     * Movie.customName; // => 'Film'
     * ```
     *
     * @category Merging
     */
    static merge(forkedComponent, options = {}) {
        assertIsComponentClass(forkedComponent);
        if (!isPrototypeOf(this, forkedComponent)) {
            throw new Error('Cannot merge a component that is not a fork of the target component');
        }
        this.__mergeAttributes(forkedComponent, options);
        return this;
    }
    /**
     * Merges the attributes of a component instance fork into the current component instance.
     *
     * @param forkedComponent The component instance fork to merge.
     *
     * @returns The current component instance.
     *
     * @example
     * ```
     * const movie = new Movie({title: 'Inception'});
     * const movieFork = movie.fork();
     * movieFork.title = 'Inception 2';
     *
     * movie.title; // => 'Inception'
     * movie.merge(movieFork);
     * movie.title; // => 'Inception 2'
     * ```
     *
     * @category Merging
     */
    merge(forkedComponent, options = {}) {
        assertIsComponentInstance(forkedComponent);
        if (!isPrototypeOf(this, forkedComponent)) {
            throw new Error('Cannot merge a component that is not a fork of the target component');
        }
        this.__mergeAttributes(forkedComponent, options);
        return this;
    }
    static get __mergeAttributes() {
        return this.prototype.__mergeAttributes;
    }
    __mergeAttributes(forkedComponent, options) {
        for (const forkedAttribute of forkedComponent.getAttributes()) {
            const name = forkedAttribute.getName();
            const attribute = this.getAttribute(name);
            if (!forkedAttribute.isSet()) {
                if (attribute.isSet()) {
                    attribute.unsetValue();
                }
                continue;
            }
            const forkedValue = forkedAttribute.getValue();
            const value = attribute.getValue({ throwIfUnset: false });
            const mergedValue = merge(value, forkedValue, options);
            attribute.setValue(mergedValue, { source: forkedAttribute.getValueSource() });
        }
    }
    // === Serialization ===
    /**
     * Serializes the component class to a plain object.
     *
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be serialized (default: `true`, which means that all the attributes will be serialized).
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be serialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.target] A number specifying the [target](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `undefined`).
     *
     * @returns A plain object representing the serialized component class.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') static customName = 'Film';
     * }
     *
     * Movie.serialize(); // => {__component: 'typeof Movie', customName: 'Film'}
     * ```
     *
     * @category Serialization
     * @possiblyasync
     */
    static serialize(options = {}) {
        const { attributeSelector = true, serializedComponents = new Set(), returnComponentReferences = false, ignoreEmptyComponents = false, includeComponentTypes = true, includeReferencedComponents = false, target, ...otherOptions } = options;
        const resolvedAttributeSelector = this.resolveAttributeSelector(attributeSelector, {
            setAttributesOnly: true,
            target,
            aggregationMode: 'intersection',
            includeReferencedComponents
        });
        return this.__serialize({
            ...otherOptions,
            attributeSelector: resolvedAttributeSelector,
            serializedComponents,
            returnComponentReferences,
            ignoreEmptyComponents,
            includeComponentTypes,
            includeReferencedComponents,
            target
        });
    }
    static __serialize(options) {
        const { serializedComponents, componentDependencies, returnComponentReferences, ignoreEmptyComponents, includeComponentTypes, includeReferencedComponents } = options;
        const serializedComponent = {};
        if (includeComponentTypes) {
            serializedComponent.__component = this.getComponentType();
        }
        const hasAlreadyBeenSerialized = serializedComponents.has(this);
        if (!hasAlreadyBeenSerialized) {
            serializedComponents.add(this);
            if (componentDependencies !== undefined) {
                for (const providedComponent of this.getProvidedComponents()) {
                    componentDependencies.add(providedComponent);
                }
                for (const consumedComponent of this.getConsumedComponents()) {
                    componentDependencies.add(consumedComponent);
                }
            }
        }
        if (hasAlreadyBeenSerialized || (returnComponentReferences && !includeReferencedComponents)) {
            return serializedComponent;
        }
        return possiblyAsync(this.__serializeAttributes(serializedComponent, options), (attributeCount) => ignoreEmptyComponents && attributeCount === 0 ? undefined : serializedComponent);
    }
    /**
     * Serializes the component instance to a plain object.
     *
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be serialized (default: `true`, which means that all the attributes will be serialized).
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be serialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.target] A number specifying the [target](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `undefined`).
     *
     * @returns A plain object representing the serialized component instance.
     *
     * @example
     * ```
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.serialize(); // => {__component: 'Movie', title: 'Inception'}
     * ```
     *
     * @category Serialization
     * @possiblyasync
     */
    serialize(options = {}) {
        const { attributeSelector = true, serializedComponents = new Set(), returnComponentReferences = false, ignoreEmptyComponents = false, includeComponentTypes = true, includeIsNewMarks = true, includeReferencedComponents = false, target, ...otherOptions } = options;
        const resolvedAttributeSelector = this.resolveAttributeSelector(attributeSelector, {
            setAttributesOnly: true,
            target,
            aggregationMode: 'intersection',
            includeReferencedComponents
        });
        return this.__serialize({
            ...otherOptions,
            attributeSelector: resolvedAttributeSelector,
            serializedComponents,
            returnComponentReferences,
            ignoreEmptyComponents,
            includeComponentTypes,
            includeIsNewMarks,
            includeReferencedComponents,
            target
        });
    }
    __serialize(options) {
        const { serializedComponents, componentDependencies, returnComponentReferences, ignoreEmptyComponents, includeComponentTypes, includeIsNewMarks, includeReferencedComponents, target } = options;
        const serializedComponent = {};
        if (includeComponentTypes) {
            serializedComponent.__component = this.getComponentType();
        }
        const isEmbedded = this.constructor.isEmbedded();
        if (!isEmbedded) {
            const hasAlreadyBeenSerialized = serializedComponents.has(this);
            if (!hasAlreadyBeenSerialized) {
                serializedComponents.add(this);
                if (componentDependencies !== undefined) {
                    componentDependencies.add(this.constructor);
                    for (const providedComponent of this.constructor.getProvidedComponents()) {
                        componentDependencies.add(providedComponent);
                    }
                    for (const consumedComponent of this.constructor.getConsumedComponents()) {
                        componentDependencies.add(consumedComponent);
                    }
                }
            }
            if (hasAlreadyBeenSerialized || (returnComponentReferences && !includeReferencedComponents)) {
                Object.assign(serializedComponent, this.getIdentifierDescriptor());
                return serializedComponent;
            }
        }
        // TODO: Rethink the whole '__new' logic
        if (includeIsNewMarks && (isEmbedded || this.getIsNewMarkSource() !== target)) {
            serializedComponent.__new = this.getIsNewMark();
        }
        return possiblyAsync(this.__serializeAttributes(serializedComponent, options), (attributeCount) => ignoreEmptyComponents && attributeCount <= this.__getMinimumAttributeCount()
            ? undefined
            : serializedComponent);
    }
    static get __serializeAttributes() {
        return this.prototype.__serializeAttributes;
    }
    __serializeAttributes(serializedComponent, options) {
        let { attributeSelector, attributeFilter } = options;
        let attributeCount = 0;
        return possiblyAsync(possiblyAsync.forEach(this.getAttributes({ attributeSelector }), (attribute) => {
            const attributeName = attribute.getName();
            const subattributeSelector = getFromAttributeSelector(attributeSelector, attributeName);
            return possiblyAsync(attributeFilter !== undefined ? attributeFilter.call(this, attribute) : true, (isNotFilteredOut) => {
                if (isNotFilteredOut) {
                    return possiblyAsync(attribute.serialize({
                        ...options,
                        attributeSelector: subattributeSelector,
                        returnComponentReferences: true
                    }), (serializedAttributeValue) => {
                        serializedComponent[attributeName] = serializedAttributeValue;
                        attributeCount++;
                    });
                }
            });
        }), () => attributeCount);
    }
    // === Deserialization ===
    /**
     * Recreates a component instance from the result of its serialization.
     *
     * @param [object] A plain object representing a serialized component.
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be deserialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `0`).
     *
     * @returns A component instance.
     *
     * @example
     * ```
     * const movie = Movie.recreate({title: 'Inception'});
     * movie.title; // => 'Inception'
     * ```
     *
     * @category Deserialization
     * @possiblyasync
     */
    static recreate(object = {}, options = {}) {
        const { __component: componentType, __new: isNew, ...attributes } = object;
        const { attributeFilter, deserializedComponents, source } = options;
        if (componentType !== undefined) {
            const expectedComponentType = this.prototype.getComponentType();
            if (componentType !== expectedComponentType) {
                throw new Error(`An unexpected component type was encountered while deserializing an object (encountered type: '${componentType}', expected type: '${expectedComponentType}')`);
            }
        }
        const { identifierAttributes } = this.prototype.__partitionAttributes(attributes);
        let component;
        if (!isNew && this.prototype.hasPrimaryIdentifierAttribute()) {
            component = this.getIdentityMap().getComponent(identifierAttributes);
        }
        if (component === undefined) {
            component = this.create(identifierAttributes, {
                isNew: Boolean(isNew),
                source,
                attributeSelector: {},
                attributeFilter,
                initialize: false
            });
        }
        else {
            if (isNew !== undefined) {
                component.setIsNewMark(isNew, { source });
            }
        }
        if (deserializedComponents !== undefined && !component.constructor.isEmbedded()) {
            deserializedComponents.add(component);
        }
        return possiblyAsync(component, (component) => possiblyAsync(component.__deserializeAttributes(attributes, options), () => {
            if (isNew) {
                for (const attribute of component.getAttributes()) {
                    if (!(attribute.isSet() || attribute.isControlled())) {
                        attribute.setValue(attribute.evaluateDefault());
                    }
                }
            }
            return possiblyAsync(component.initialize(), () => component);
        }));
    }
    /**
     * Deserializes the component class from the specified plain object. The deserialization operates "in place", which means that the current component class attributes are mutated.
     *
     * @param [object] The plain object to deserialize from.
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be deserialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `0`).
     *
     * @returns The component class.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') static customName = 'Movie';
     * }
     *
     * Movie.customName; // => 'Movie'
     * Movie.deserialize({customName: 'Film'});
     * Movie.customName; // => 'Film'
     * ```
     *
     * @category Deserialization
     * @possiblyasync
     */
    static deserialize(object = {}, options = {}) {
        const { __component: componentType, ...attributes } = object;
        const { deserializedComponents } = options;
        if (componentType !== undefined) {
            const expectedComponentType = this.getComponentType();
            if (componentType !== expectedComponentType) {
                throw new Error(`An unexpected component type was encountered while deserializing an object (encountered type: '${componentType}', expected type: '${expectedComponentType}')`);
            }
        }
        if (deserializedComponents !== undefined) {
            deserializedComponents.add(this);
        }
        return possiblyAsync(this.__deserializeAttributes(attributes, options), () => possiblyAsync(this.initialize(), () => this));
    }
    /**
     * Deserializes the component instance from the specified plain object. The deserialization operates "in place", which means that the current component instance attributes are mutated.
     *
     * @param [object] The plain object to deserialize from.
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be deserialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `0`).
     *
     * @returns The current component instance.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') title = '';
     * }
     *
     * const movie = new Movie();
     *
     * movie.title; // => ''
     * movie.deserialize({title: 'Inception'});
     * movie.title; // => 'Inception'
     * ```
     *
     * @category Deserialization
     * @possiblyasync
     */
    deserialize(object = {}, options = {}) {
        const { deserializedComponents, source } = options;
        const { __component: componentType, __new: isNew, ...attributes } = object;
        if (componentType !== undefined) {
            const expectedComponentType = this.getComponentType();
            if (componentType !== expectedComponentType) {
                throw new Error(`An unexpected component type was encountered while deserializing an object (encountered type: '${componentType}', expected type: '${expectedComponentType}')`);
            }
        }
        if (isNew !== undefined) {
            if (isNew && !this.getIsNewMark()) {
                throw new Error(`Cannot mark as new an existing non-new component (${this.describeComponent()})`);
            }
            this.setIsNewMark(isNew, { source });
        }
        if (deserializedComponents !== undefined && !this.constructor.isEmbedded()) {
            deserializedComponents.add(this);
        }
        return possiblyAsync(this.__deserializeAttributes(attributes, options), () => possiblyAsync(this.initialize(), () => this));
    }
    static get __deserializeAttributes() {
        return this.prototype.__deserializeAttributes;
    }
    __deserializeAttributes(serializedAttributes, options) {
        const { attributeFilter } = options;
        const componentClass = ensureComponentClass(this);
        const componentGetter = (type) => componentClass.getComponentOfType(type);
        return possiblyAsync.forEach(Object.entries(serializedAttributes), ([attributeName, serializedAttributeValue]) => {
            const attribute = this.getAttribute(attributeName);
            return possiblyAsync(attributeFilter !== undefined ? attributeFilter.call(this, attribute) : true, (isNotFilteredOut) => {
                if (isNotFilteredOut) {
                    return this.__deserializeAttribute(attribute, serializedAttributeValue, componentGetter, options);
                }
            });
        });
    }
    static get __deserializeAttribute() {
        return this.prototype.__deserializeAttribute;
    }
    __deserializeAttribute(attribute, serializedAttributeValue, componentGetter, options) {
        const { source = 0 } = options;
        // OPTIMIZE: Move the following logic into the Attribute class so we can avoid
        // deserializing two times in case of in place deserialization of nested models
        return possiblyAsync(deserialize(serializedAttributeValue, { ...options, componentGetter }), (newAttributeValue) => {
            if (attribute.isSet()) {
                const previousAttributeValue = attribute.getValue();
                if (newAttributeValue === previousAttributeValue) {
                    // Optimization
                    attribute.setValueSource(source);
                    return;
                }
                if (isComponentClassOrInstance(newAttributeValue) &&
                    isComponentClassOrInstance(previousAttributeValue) &&
                    newAttributeValue.getComponentType() === previousAttributeValue.getComponentType()) {
                    return previousAttributeValue.deserialize(serializedAttributeValue, options);
                }
            }
            attribute.setValue(newAttributeValue, { source });
        });
    }
    // === Introspection ===
    static introspect({ _introspectedComponents = new Map() } = {}) {
        if (_introspectedComponents.has(this)) {
            return _introspectedComponents.get(this);
        }
        let introspectedComponent;
        const introspectedProperties = this.__introspectProperties();
        const introspectedPrototypeProperties = this.prototype.__introspectProperties();
        const introspectedProvidedComponents = this.__introspectProvidedComponents({
            _introspectedComponents
        });
        if (introspectedProperties.length > 0 ||
            introspectedPrototypeProperties.length > 0 ||
            introspectedProvidedComponents.length > 0) {
            introspectedComponent = {
                name: this.getComponentName()
            };
        }
        _introspectedComponents.set(this, introspectedComponent);
        if (introspectedComponent === undefined) {
            return undefined;
        }
        if (this.isEmbedded()) {
            introspectedComponent.isEmbedded = true;
        }
        const introspectedMixins = this.__introspectMixins();
        if (introspectedMixins.length > 0) {
            introspectedComponent.mixins = introspectedMixins;
        }
        if (introspectedProperties.length > 0) {
            introspectedComponent.properties = introspectedProperties;
        }
        if (introspectedPrototypeProperties.length > 0) {
            introspectedComponent.prototype = { properties: introspectedPrototypeProperties };
        }
        if (introspectedProvidedComponents.length > 0) {
            introspectedComponent.providedComponents = introspectedProvidedComponents;
        }
        const introspectedConsumedComponents = this.__introspectConsumedComponents({
            _introspectedComponents
        });
        if (introspectedConsumedComponents.length > 0) {
            introspectedComponent.consumedComponents = introspectedConsumedComponents;
        }
        return introspectedComponent;
    }
    static __introspectMixins() {
        const introspectedMixins = new Array();
        let currentClass = this;
        while (isComponentClass(currentClass)) {
            if (hasOwnProperty(currentClass, '__mixin')) {
                const mixinName = currentClass.__mixin;
                if (!introspectedMixins.includes(mixinName)) {
                    introspectedMixins.unshift(mixinName);
                }
            }
            currentClass = Object.getPrototypeOf(currentClass);
        }
        return introspectedMixins;
    }
    static get __introspectProperties() {
        return this.prototype.__introspectProperties;
    }
    __introspectProperties() {
        const introspectedProperties = [];
        for (const property of this.getProperties({ autoFork: false })) {
            const introspectedProperty = property.introspect();
            if (introspectedProperty !== undefined) {
                introspectedProperties.push(introspectedProperty);
            }
        }
        return introspectedProperties;
    }
    static __introspectProvidedComponents({ _introspectedComponents }) {
        const introspectedProvidedComponents = [];
        for (const providedComponent of this.getProvidedComponents()) {
            const introspectedProvidedComponent = providedComponent.introspect({ _introspectedComponents });
            if (introspectedProvidedComponent !== undefined) {
                introspectedProvidedComponents.push(introspectedProvidedComponent);
            }
        }
        return introspectedProvidedComponents;
    }
    static __introspectConsumedComponents({ _introspectedComponents }) {
        const introspectedConsumedComponents = [];
        for (const consumedComponent of this.getConsumedComponents()) {
            const introspectedConsumedComponent = consumedComponent.introspect({ _introspectedComponents });
            if (introspectedConsumedComponent !== undefined) {
                introspectedConsumedComponents.push(consumedComponent.getComponentName());
            }
        }
        return introspectedConsumedComponents;
    }
    static unintrospect(introspectedComponent, options = {}) {
        const { name, isEmbedded, mixins: introspectedMixins, properties: introspectedProperties, prototype: { properties: introspectedPrototypeProperties } = {}, providedComponents: introspectedProvidedComponents, consumedComponents: introspectedConsumedComponents } = introspectedComponent;
        const { mixins = [], methodBuilder } = options;
        let UnintrospectedComponent = class extends Component {
        };
        if (isEmbedded) {
            UnintrospectedComponent.isEmbedded = function () {
                return true;
            };
        }
        if (introspectedMixins !== undefined) {
            UnintrospectedComponent = UnintrospectedComponent.__unintrospectMixins(introspectedMixins, {
                mixins
            });
        }
        const propertyClassGetter = UnintrospectedComponent.getPropertyClass;
        if (introspectedProperties !== undefined) {
            UnintrospectedComponent.__unintrospectProperties(introspectedProperties, propertyClassGetter, { methodBuilder });
        }
        if (introspectedPrototypeProperties !== undefined) {
            UnintrospectedComponent.prototype.__unintrospectProperties(introspectedPrototypeProperties, propertyClassGetter, { methodBuilder });
        }
        UnintrospectedComponent.setComponentName(name);
        if (introspectedProvidedComponents !== undefined) {
            UnintrospectedComponent.__unintrospectProvidedComponents(introspectedProvidedComponents, {
                mixins,
                methodBuilder
            });
        }
        if (introspectedConsumedComponents !== undefined) {
            UnintrospectedComponent.__unintrospectConsumedComponents(introspectedConsumedComponents);
        }
        UnintrospectedComponent.__setRemoteComponent(UnintrospectedComponent);
        if (methodBuilder !== undefined) {
            UnintrospectedComponent.__setRemoteMethodBuilder(methodBuilder);
        }
        return UnintrospectedComponent;
    }
    static __unintrospectMixins(introspectedMixins, { mixins }) {
        let UnintrospectedComponentWithMixins = this;
        for (const mixinName of introspectedMixins) {
            const Mixin = mixins.find((Mixin) => getFunctionName(Mixin) === mixinName);
            if (Mixin === undefined) {
                throw new Error(`Couldn't find a component mixin named '${mixinName}'. Please make sure you specified it when creating your 'ComponentClient'.`);
            }
            UnintrospectedComponentWithMixins = Mixin(UnintrospectedComponentWithMixins);
        }
        return UnintrospectedComponentWithMixins;
    }
    static get __unintrospectProperties() {
        return this.prototype.__unintrospectProperties;
    }
    __unintrospectProperties(introspectedProperties, propertyClassGetter, { methodBuilder }) {
        var _a, _b;
        for (const introspectedProperty of introspectedProperties) {
            const { type } = introspectedProperty;
            const PropertyClass = propertyClassGetter.call(ensureComponentClass(this), type);
            const { name, options } = PropertyClass.unintrospect(introspectedProperty);
            const property = this.setProperty(name, PropertyClass, options);
            if (isAttributeInstance(property)) {
                if (((_a = property.getExposure()) === null || _a === void 0 ? void 0 : _a.set) !== true) {
                    property.markAsControlled();
                }
            }
            else if (isMethodInstance(property)) {
                if (((_b = property.getExposure()) === null || _b === void 0 ? void 0 : _b.call) === true &&
                    methodBuilder !== undefined &&
                    !(name in this)) {
                    Object.defineProperty(this, name, {
                        value: methodBuilder(name),
                        writable: true,
                        enumerable: false,
                        configurable: true
                    });
                }
            }
        }
    }
    static __unintrospectProvidedComponents(introspectedProvidedComponents, { mixins, methodBuilder }) {
        for (const introspectedProvidedComponent of introspectedProvidedComponents) {
            this.provideComponent(Component.unintrospect(introspectedProvidedComponent, { mixins, methodBuilder }));
        }
    }
    static __unintrospectConsumedComponents(introspectedConsumedComponents) {
        for (const introspectedConsumedComponent of introspectedConsumedComponents) {
            this.consumeComponent(introspectedConsumedComponent);
        }
    }
    static getRemoteComponent() {
        return this.__remoteComponent;
    }
    getRemoteComponent() {
        var _a;
        return (_a = this.constructor.getRemoteComponent()) === null || _a === void 0 ? void 0 : _a.prototype;
    }
    static __setRemoteComponent(remoteComponent) {
        Object.defineProperty(this, '__remoteComponent', { value: remoteComponent });
    }
    // === Remote methods ===
    static get hasRemoteMethod() {
        return this.prototype.hasRemoteMethod;
    }
    hasRemoteMethod(name) {
        var _a;
        const remoteComponent = this.getRemoteComponent();
        if (!(remoteComponent === null || remoteComponent === void 0 ? void 0 : remoteComponent.hasMethod(name))) {
            return false;
        }
        const remoteMethod = remoteComponent.getMethod(name, { autoFork: false });
        return ((_a = remoteMethod.getExposure()) === null || _a === void 0 ? void 0 : _a.call) === true;
    }
    static get callRemoteMethod() {
        return this.prototype.callRemoteMethod;
    }
    callRemoteMethod(name, ...args) {
        const remoteMethodBuilder = ensureComponentClass(this).__remoteMethodBuilder;
        if (remoteMethodBuilder === undefined) {
            throw new Error(`Cannot call the remote method '${name}' for a component that does not come from a component client (${this.describeComponent()})`);
        }
        return remoteMethodBuilder(name).apply(this, args);
    }
    static __setRemoteMethodBuilder(methodBuilder) {
        Object.defineProperty(this, '__remoteMethodBuilder', { value: methodBuilder });
    }
    // === Utilities ===
    static isComponent(value) {
        return isComponentInstance(value);
    }
    static get toObject() {
        return this.prototype.toObject;
    }
    toObject(options = {}) {
        const { minimize = false } = options;
        if (minimize) {
            if (isComponentClass(this)) {
                return {};
            }
            if (this.hasIdentifiers()) {
                return this.getIdentifierDescriptor();
            }
        }
        const object = {};
        const handleValue = (value) => {
            if (isComponentClassOrInstance(value)) {
                const component = value;
                if (!ensureComponentClass(component).isEmbedded()) {
                    return component.toObject({ minimize: true });
                }
                else {
                    return component.toObject({ minimize });
                }
            }
            if (Array.isArray(value)) {
                return value.map(handleValue);
            }
            return value;
        };
        for (const attribute of this.getAttributes({ setAttributesOnly: true })) {
            object[attribute.getName()] = handleValue(attribute.getValue());
        }
        return object;
    }
    static get describeComponent() {
        return this.prototype.describeComponent;
    }
    describeComponent(options = {}) {
        let { componentPrefix = '' } = options;
        if (componentPrefix !== '') {
            componentPrefix = `${componentPrefix} `;
        }
        return `${componentPrefix}component: '${ensureComponentClass(this).getComponentPath()}'`;
    }
    static describeComponentProperty(name) {
        return `${this.getComponentPath()}.${name}`;
    }
    describeComponentProperty(name) {
        return `${this.constructor.getComponentPath()}.prototype.${name}`;
    }
}
function createPropertyFilter(originalFilter, options = {}) {
    const { attributesOnly = false, attributeSelector = true, setAttributesOnly = false, methodsOnly = false } = options;
    const normalizedAttributeSelector = normalizeAttributeSelector(attributeSelector);
    const filter = function (property) {
        if (isAttributeInstance(property)) {
            const attribute = property;
            if (setAttributesOnly && !attribute.isSet()) {
                return false;
            }
            const name = attribute.getName();
            if (getFromAttributeSelector(normalizedAttributeSelector, name) === false) {
                return false;
            }
        }
        else if (attributesOnly) {
            return false;
        }
        if (isMethodInstance(property)) {
            // NOOP
        }
        else if (methodsOnly) {
            return false;
        }
        if (originalFilter !== undefined) {
            return originalFilter.call(this, property);
        }
        return true;
    };
    return filter;
}
//# sourceMappingURL=component.js.map