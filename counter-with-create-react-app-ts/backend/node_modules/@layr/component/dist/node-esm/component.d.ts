import { PlainObject, PromiseLikeable } from 'core-helpers';
import { Property, PropertyOptions, PropertyOperationSetting, PropertyFilter, PropertyFilterSync, PropertyFilterAsync, IntrospectedProperty, Attribute, AttributeOptions, IntrospectedAttribute, IdentifierAttribute, PrimaryIdentifierAttribute, SecondaryIdentifierAttribute, IdentifierValue, AttributeSelector, Method, MethodOptions, IntrospectedMethod } from './properties';
import { IdentityMap } from './identity-map';
import { CloneOptions } from './cloning';
import { ForkOptions } from './forking';
import { MergeOptions } from './merging';
import { SerializeOptions } from './serialization';
import { DeserializeOptions } from './deserialization';
export declare type ComponentSet = Set<typeof Component | Component>;
export declare type ComponentGetter = (type: string) => typeof Component | Component;
export declare type ComponentMixin = (Base: typeof Component) => typeof Component;
export declare type TraverseAttributesIteratee = (attribute: Attribute) => void;
export declare type TraverseAttributesOptions = {
    attributeSelector: AttributeSelector;
    setAttributesOnly: boolean;
};
export declare type IdentifierObject = {
    [name: string]: IdentifierValue;
};
export declare type IdentifierDescriptor = NormalizedIdentifierDescriptor | string | number;
export declare type NormalizedIdentifierDescriptor = {
    [name: string]: IdentifierValue;
};
export declare type ResolveAttributeSelectorOptions = {
    filter?: PropertyFilterSync;
    setAttributesOnly?: boolean;
    target?: number;
    aggregationMode?: 'union' | 'intersection';
    includeReferencedComponents?: boolean;
    alwaysIncludePrimaryIdentifierAttributes?: boolean;
    allowPartialArrayItems?: boolean;
    depth?: number;
    _isDeep?: boolean;
    _skipUnchangedAttributes?: boolean;
    _isArrayItem?: boolean;
    _attributeStack?: Set<Attribute>;
};
declare type MethodBuilder = (name: string) => Function;
export declare type IntrospectedComponent = {
    name: string;
    isEmbedded?: boolean;
    mixins?: string[];
    properties?: (IntrospectedProperty | IntrospectedAttribute | IntrospectedMethod)[];
    prototype?: {
        properties?: (IntrospectedProperty | IntrospectedAttribute | IntrospectedMethod)[];
    };
    providedComponents?: IntrospectedComponent[];
    consumedComponents?: string[];
};
declare type IntrospectedComponentMap = Map<typeof Component, IntrospectedComponent | undefined>;
declare const Component_base: {
    new (...args: any[]): {
        addObserver(observer: import("@layr/observable").Observer): void;
        removeObserver(observer: import("@layr/observable").Observer): void;
        callObservers(payload?: import("@layr/observable").ObserverPayload | undefined): void;
        __observers?: import("@layr/observable").ObserverSet | undefined;
        __getObservers(): import("@layr/observable").ObserverSet;
        isObservable(value: any): value is import("@layr/observable").ObservableType;
    };
    readonly addObserver: any;
    readonly removeObserver: any;
    readonly callObservers: any;
    __observers?: import("@layr/observable").ObserverSet | undefined;
    readonly __getObservers: any;
    readonly isObservable: any;
} & ObjectConstructor;
/**
 * *Inherits from [`Observable`](https://layrjs.com/docs/v1/reference/observable#observable-class).*
 *
 * A component is an elementary building block allowing you to define your data models and implement the business logic of your application. Typically, an application is composed of several components that are connected to each other by using the [`@provide()`](https://layrjs.com/docs/v1/reference/component#provide-decorator) and [`@consume()`](https://layrjs.com/docs/v1/reference/component#consume-decorator) decorators.
 *
 * #### Usage
 *
 * Just extend the `Component` class to define a component with some attributes and methods that are specific to your application.
 *
 * For example, a `Movie` component with a `title` attribute and a `play()` method could be defined as follows:
 *
 * ```
 * // JS
 *
 * import {Component} from '@layr/component';
 *
 * class Movie extends Component {
 *   ﹫attribute('string') title;
 *
 *   ﹫method() play() {
 *     console.log(`Playing '${this.title}...'`);
 *   }
 * }
 * ```
 *
 * ```
 * // TS
 *
 * import {Component} from '@layr/component';
 *
 * class Movie extends Component {
 *   ﹫attribute('string') title!: string;
 *
 *   ﹫method() play() {
 *     console.log(`Playing '${this.title}...'`);
 *   }
 * }
 * ```
 *
 * The [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) and [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator) decorators allows you to get the full power of Layr, such as attribute type checking, or remote method invocation.
 *
 * Once you have defined a component, you can use it as any JavaScript class:
 *
 * ```
 * const movie = new Movie({title: 'Inception'});
 *
 * movie.play(); // => 'Playing Inception...'
 * ```
 *
 * #### Nesting Components
 *
 * Components can be nested either by embedding or by referencing.
 *
 * ##### Embedding Components
 *
 * Use the [`EmbeddedComponent`](https://layrjs.com/docs/v1/reference/embedded-component) class to embed a component into another component. An embedded component is strongly attached to the parent component that owns it, and it cannot "live" by itself like a regular component.
 *
 * Here are some characteristics of an embedded component:
 *
 * - An embedded component has one parent only, and therefore cannot be embedded in more than one component.
 * - When the parent of an embedded component is [validated](https://layrjs.com/docs/v1/reference/validator), the embedded component is validated as well.
 * - When the parent of an embedded component is loaded, saved, or deleted (using a [`StorableComponent`](https://layrjs.com/docs/v1/reference/storable#storage-operations) method), the embedded component is loaded, saved, or deleted as well.
 *
 * See the [`EmbeddedComponent`](https://layrjs.com/docs/v1/reference/embedded-component) class for an example of use.
 *
 * ##### Referencing Components
 *
 * Any non-embedded component can be referenced by another component. Contrary to an embedded component, a referenced component is an independent entity that can "live" by itself. So a referenced component behaves like a regular JavaScript object that is referenced by another object.
 *
 * Here are some characteristics of a referenced component:
 *
 * - A referenced component can be referenced by any number of components.
 * - When a component holding a reference to another component is [validated](https://layrjs.com/docs/v1/reference/validator), the referenced component is considered as an independent entity, and is therefore not automatically validated.
 * - When a component holding a reference to another component is loaded, saved, or deleted (using a [`StorableComponent`](https://layrjs.com/docs/v1/reference/storable#storage-operations) method), the referenced component can be loaded in the same operation, but it has to be saved or deleted independently.
 *
 * For example, let's say we have a `Director` component defined as follows:
 *
 * ```
 * // JS
 *
 * class Director extends Component {
 *   ﹫attribute('string') fullName;
 * }
 * ```
 *
 * ```
 * // TS
 *
 * class Director extends Component {
 *   ﹫attribute('string') fullName!: string;
 * }
 * ```
 *
 * Next, we can add an attribute to the `Movie` component to store a reference to a `Director`:
 *
 * ```
 * // JS
 *
 * class Movie extends Component {
 *   ﹫provide() static Director = Director;
 *
 *   // ...
 *
 *   ﹫attribute('Director') director;
 * }
 * ```
 *
 * ```
 * // TS
 *
 * class Movie extends Component {
 *   ﹫provide() static Director = Director;
 *
 *   // ...
 *
 *   ﹫attribute('Director') director!: Director;
 * }
 * ```
 *
 * > Note that to be able to specify the `'Director'` type for the `director` attribute, you first have to provide the `Director` component to the `Movie` component by using the [`@provide()`](https://layrjs.com/docs/v1/reference/component#provide-decorator) decorator.
 *
 *  Then, to create a `Movie` with a `Director`, we can do something like:
 *
 * ```
 * const movie = new Movie({
 *   title: 'Inception',
 *   director: new Movie.Director({fullName: 'Christopher Nolan'})
 * });
 *
 * movie.title; // => 'Inception'
 * movie.director.fullName; // => 'Christopher Nolan'
 * ```
 */
export declare class Component extends Component_base {
    ['constructor']: typeof Component;
    /**
     * Creates an instance of a component class.
     *
     * @param [object] An optional object specifying the value of the component attributes.
     *
     * @returns The component instance that was created.
     *
     * @example
     * ```
     * // JS
     *
     * import {Component, attribute} from '﹫layr/component';
     *
     * class Movie extends Component {
     *   ﹫attribute('string') title;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title // => 'Inception'
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * import {Component, attribute} from '﹫layr/component';
     *
     * class Movie extends Component {
     *   ﹫attribute('string') title!: string;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title // => 'Inception'
     * ```
     *
     * @category Creation
     */
    constructor(object?: PlainObject);
    /**
     * Creates an instance of a component class.
     *
     * @param [object] An optional object specifying the value of the component attributes.
     * @param [options.isNew] Whether the instance should be marked as new or not (default: `true`).
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the created instance (default: `0`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be set (default: `true`, which means that all the attributes will be set).
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be set. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.initialize] Whether to call the [`initialize`](https://layrjs.com/docs/v1/reference/component#initialize-instance-method) instance method or not (default: `true`).
     *
     * @returns An instance of the component class (possibly a promise if `options.attributeFilter` is an async function or `options.initialize` is `true` and the class has an async [`initialize`](https://layrjs.com/docs/v1/reference/component#initialize-instance-method) instance method).
     *
     * @example
     * ```
     * let movie = Movie.create({title: 'Inception'});
     *
     * movie.title // => 'Inception'
     * ```
     *
     * @category Creation
     * @possiblyasync
     */
    static create<T extends typeof Component>(this: T, object: PlainObject | null | undefined, options: {
        isNew?: boolean;
        source?: number;
        attributeSelector?: AttributeSelector;
        attributeFilter: PropertyFilterAsync;
        initialize?: boolean;
    }): PromiseLike<InstanceType<T>>;
    static create<T extends typeof Component>(this: T, object: PlainObject | null | undefined, options: {
        isNew?: boolean;
        source?: number;
        attributeSelector?: AttributeSelector;
        attributeFilter?: PropertyFilter;
        initialize: false;
    }): InstanceType<T>;
    static create<T extends typeof Component>(this: T, object?: PlainObject | null, options?: {
        isNew?: boolean;
        source?: number;
        attributeSelector?: AttributeSelector;
        attributeFilter?: PropertyFilter;
        initialize?: boolean;
    }): ReturnType<InstanceType<T>['initialize']> extends PromiseLike<void> ? PromiseLike<InstanceType<T>> : InstanceType<T>;
    /**
     * A (possibly async) method that is called automatically when the component class is deserialized. You can override this method in your component subclasses to implement your initialization logic.
     *
     * @category Initialization
     * @possiblyasync
     */
    static initialize(): void;
    /**
     * A (possibly async) method that is called automatically when the component instance is created or deserialized. You can override this method in your component subclasses to implement your initialization logic.
     *
     * @category Initialization
     * @possiblyasync
     */
    initialize(): void;
    static getBaseComponentName(): string;
    /**
     * Returns the name of the component, which is usually the name of the corresponding class.
     *
     * @returns A string.
     *
     * @example
     * ```
     * Movie.getComponentName(); // => 'Movie'
     * ```
     *
     * @category Naming
     */
    static getComponentName(): string;
    /**
     * Sets the name of the component. As the name of a component is usually inferred from the name of its class, this method should not be used so often.
     *
     * @param name The name you wish for the component.
     *
     * @example
     * ```
     * Movie.getComponentName(); // => 'Movie'
     * Movie.setComponentName('Film');
     * Movie.getComponentName(); // => 'Film'
     * ```
     *
     * @category Naming
     */
    static setComponentName(name: string): void;
    /**
     * Returns the path of the component starting from its root component.
     *
     * For example, if a `Backend` component provides a `Movie` component, this method will return `'Backend.Movie'` when called on the `Movie` component.
     *
     * @returns A string.
     *
     * @example
     * ```
     * class Movie extends Component {}
     *
     * Movie.getComponentPath(); // => 'Movie'
     *
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Movie.getComponentPath(); // => 'Backend.Movie'
     * ```
     *
     * @category Naming
     */
    static getComponentPath(): string;
    static getBaseComponentType(): string;
    getBaseComponentType(): string;
    /**
     * Returns the type of the component class. A component class type is composed of the component class name prefixed with the string `'typeof '`.
     *
     * For example, with a component class named `'Movie'`, this method will return `'typeof Movie'`.
     *
     * @returns A string.
     *
     * @example
     * ```
     * Movie.getComponentType(); // => 'typeof Movie'
     * ```
     *
     * @category Typing
     */
    static getComponentType(): string;
    /**
     * Returns the type of the component instance. A component instance type is equivalent to the component class name.
     *
     * For example, with a component class named `'Movie'`, this method will return `'Movie'` when called on a `Movie` instance.
     *
     * @returns A string.
     *
     * @example
     * ```
     * movie.getComponentType(); // => 'Movie'
     * Movie.prototype.getComponentType(); // => 'Movie'
     * ```
     *
     * @category Typing
     */
    getComponentType(): string;
    __isNew: boolean | undefined;
    /**
     * Returns whether the component instance is marked as new or not.
     *
     * @alias isNew
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * let movie = new Movie();
     * movie.getIsNewMark(); // => true
     *
     * movie = Movie.recreate();
     * movie.getIsNewMark(); // => false
     * ```
     *
     * @category isNew Mark
     */
    getIsNewMark(): boolean;
    /**
     * Sets whether the component instance is marked as new or not.
     *
     * @param isNew A boolean specifying if the component instance should be marked as new or not.
     *
     * @example
     * ```
     * const movie = new Movie();
     * movie.getIsNewMark(); // => true
     * movie.setIsNewMark(false);
     * movie.getIsNewMark(); // => false
     * ```
     *
     * @category isNew Mark
     */
    setIsNewMark(isNew: boolean, { source }?: {
        source?: number;
    }): void;
    /**
     * Returns whether the component instance is marked as new or not.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * let movie = new Movie();
     * movie.isNew(); // => true
     *
     * movie = Movie.recreate();
     * movie.isNew(); // => false
     * ```
     *
     * @category isNew Mark
     */
    isNew(): boolean;
    /**
     * Marks the component instance as new.
     *
     * This method is a shortcut for `setIsNewMark(true)`.
     *
     * @category isNew Mark
     */
    markAsNew({ source }?: {
        source?: number;
    }): void;
    /**
     * Marks the component instance as not new.
     *
     * This method is a shortcut for `setIsNewMark(false)`.
     *
     * @category isNew Mark
     */
    markAsNotNew({ source }?: {
        source?: number;
    }): void;
    __isNewSource: number | undefined;
    getIsNewMarkSource(): number;
    setIsNewMarkSource(source?: number): void;
    /**
     * See the methods that are inherited from the [`Observable`](https://layrjs.com/docs/v1/reference/observable#observable-class) class.
     *
     * @category Observability
     */
    /**
     * Returns whether the component is an [`EmbeddedComponent`](https://layrjs.com/docs/v1/reference/embedded-component).
     *
     * @returns A boolean.
     *
     * @category Embeddability
     */
    static isEmbedded(): boolean;
    static getPropertyClass(type: string): typeof Property;
    /**
     * Gets a property of the component.
     *
     * @param name The name of the property to get.
     *
     * @returns An instance of a [`Property`](https://layrjs.com/docs/v1/reference/property) (or a subclass of [`Property`](https://layrjs.com/docs/v1/reference/property) such as [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method), etc.).
     *
     * @example
     * ```
     * movie.getProperty('title'); // => 'title' attribute property
     * movie.getProperty('play'); // => 'play()' method property
     * ```
     *
     * @category Properties
     */
    static get getProperty(): (name: string, options?: {
        autoFork?: boolean | undefined;
    }) => Property;
    /**
     * Gets a property of the component.
     *
     * @param name The name of the property to get.
     *
     * @returns An instance of a [`Property`](https://layrjs.com/docs/v1/reference/property) (or a subclass of [`Property`](https://layrjs.com/docs/v1/reference/property) such as [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method), etc.).
     *
     * @example
     * ```
     * movie.getProperty('title'); // => 'title' attribute property
     * movie.getProperty('play'); // => 'play()' method property
     * ```
     *
     * @category Properties
     */
    getProperty(name: string, options?: {
        autoFork?: boolean;
    }): Property;
    /**
     * Returns whether the component has the specified property.
     *
     * @param name The name of the property to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasProperty('title'); // => true
     * movie.hasProperty('play'); // => true
     * movie.hasProperty('name'); // => false
     * ```
     *
     * @category Properties
     */
    static get hasProperty(): (name: string) => boolean;
    /**
     * Returns whether the component has the specified property.
     *
     * @param name The name of the property to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasProperty('title'); // => true
     * movie.hasProperty('play'); // => true
     * movie.hasProperty('name'); // => false
     * ```
     *
     * @category Properties
     */
    hasProperty(name: string): boolean;
    static get __getProperty(): (name: string, options: {
        autoFork: boolean;
    }) => Property | undefined;
    __getProperty(name: string, options: {
        autoFork: boolean;
    }): Property | undefined;
    /**
     * Defines a property in the component. Typically, instead of using this method, you would rather use a decorator such as [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) or [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator).
     *
     * @param name The name of the property to define.
     * @param PropertyClass The class of the property (e.g., [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method)) to use.
     * @param [propertyOptions] The options to create the `PropertyClass`.
     *
     * @returns The property that was created.
     *
     * @example
     * ```
     * Movie.prototype.setProperty('title', Attribute, {valueType: 'string'});
     * ```
     *
     * @category Properties
     */
    static get setProperty(): <T extends typeof Property>(name: string, PropertyClass: T, propertyOptions?: PropertyOptions | undefined) => InstanceType<T>;
    /**
     * Defines a property in the component. Typically, instead of using this method, you would rather use a decorator such as [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) or [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator).
     *
     * @param name The name of the property to define.
     * @param PropertyClass The class of the property (e.g., [`Attribute`](https://layrjs.com/docs/v1/reference/attribute), [`Method`](https://layrjs.com/docs/v1/reference/method)) to use.
     * @param [propertyOptions] The options to create the `PropertyClass`.
     *
     * @returns The property that was created.
     *
     * @example
     * ```
     * Movie.prototype.setProperty('title', Attribute, {valueType: 'string'});
     * ```
     *
     * @category Properties
     */
    setProperty<T extends typeof Property>(name: string, PropertyClass: T, propertyOptions?: PropertyOptions): InstanceType<T>;
    /**
     * Removes a property from the component. If the specified property doesn't exist, nothing happens.
     *
     * @param name The name of the property to remove.
     *
     * @returns A boolean.
     *
     * @category Properties
     */
    static get deleteProperty(): (name: string) => boolean;
    /**
     * Removes a property from the component. If the specified property doesn't exist, nothing happens.
     *
     * @param name The name of the property to remove.
     *
     * @returns A boolean.
     *
     * @category Properties
     */
    deleteProperty(name: string): boolean;
    /**
     * Returns an iterator providing the properties of the component.
     *
     * @param [options.filter] A function used to filter the properties to be returned. The function is invoked for each property with a [`Property`](https://layrjs.com/docs/v1/reference/property) instance as first argument.
     * @param [options.attributesOnly] A boolean specifying whether only attribute properties should be returned (default: `false`).
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     * @param [options.methodsOnly] A boolean specifying whether only method properties should be returned (default: `false`).
     *
     * @returns A [`Property`](https://layrjs.com/docs/v1/reference/property) instance iterator.
     *
     * @example
     * ```
     * for (const property of movie.getProperties()) {
     *   console.log(property.getName());
     * }
     *
     * // Should output:
     * // title
     * // play
     * ```
     *
     * @category Properties
     */
    static get getProperties(): <PropertyType extends Property = Property>(options?: {
        filter?: PropertyFilterSync | undefined;
        autoFork?: boolean | undefined;
    } & {
        attributesOnly?: boolean | undefined;
        methodsOnly?: boolean | undefined;
    } & CreatePropertyFilterOptionsForAttributes) => {
        [Symbol.iterator](): Generator<PropertyType, void, unknown>;
    };
    /**
     * Returns an iterator providing the properties of the component.
     *
     * @param [options.filter] A function used to filter the properties to be returned. The function is invoked for each property with a [`Property`](https://layrjs.com/docs/v1/reference/property) instance as first argument.
     * @param [options.attributesOnly] A boolean specifying whether only attribute properties should be returned (default: `false`).
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     * @param [options.methodsOnly] A boolean specifying whether only method properties should be returned (default: `false`).
     *
     * @returns A [`Property`](https://layrjs.com/docs/v1/reference/property) instance iterator.
     *
     * @example
     * ```
     * for (const property of movie.getProperties()) {
     *   console.log(property.getName());
     * }
     *
     * // Should output:
     * // title
     * // play
     * ```
     *
     * @category Properties
     */
    getProperties<PropertyType extends Property = Property>(options?: {
        filter?: PropertyFilterSync;
        autoFork?: boolean;
    } & CreatePropertyFilterOptions): {
        [Symbol.iterator](): Generator<PropertyType, void, unknown>;
    };
    static __properties?: {
        [name: string]: Property;
    };
    __properties?: {
        [name: string]: Property;
    };
    /**
     * Returns the name of all the properties of the component.
     *
     * @returns An array of the property names.
     *
     * @example
     * ```
     * movie.getPropertyNames(); // => ['title', 'play']
     * ```
     *
     * @category Properties
     */
    static get getPropertyNames(): () => string[];
    /**
     * Returns the name of all the properties of the component.
     *
     * @returns An array of the property names.
     *
     * @example
     * ```
     * movie.getPropertyNames(); // => ['title', 'play']
     * ```
     *
     * @category Properties
     */
    getPropertyNames(): string[];
    static get __getProperties(): ({ autoCreateOrFork }?: {
        autoCreateOrFork?: boolean | undefined;
    }) => {
        [name: string]: Property;
    };
    __getProperties({ autoCreateOrFork }?: {
        autoCreateOrFork?: boolean | undefined;
    }): {
        [name: string]: Property;
    };
    static normalizePropertyOperationSetting(setting: PropertyOperationSetting, options?: {
        throwIfInvalid?: boolean;
    }): PropertyOperationSetting | undefined;
    static get resolvePropertyOperationSetting(): (setting: PropertyOperationSetting) => PromiseLikeable<boolean | undefined>;
    resolvePropertyOperationSetting(setting: PropertyOperationSetting): PromiseLikeable<boolean | undefined>;
    __constructorSourceCode?: string;
    /**
     * Gets an attribute of the component.
     *
     * @param name The name of the attribute to get.
     *
     * @returns An instance of [`Attribute`](https://layrjs.com/docs/v1/reference/attribute).
     *
     * @example
     * ```
     * movie.getAttribute('title'); // => 'title' attribute property
     * movie.getAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    static get getAttribute(): (name: string, options?: {
        autoFork?: boolean | undefined;
    }) => Attribute;
    /**
     * Gets an attribute of the component.
     *
     * @param name The name of the attribute to get.
     *
     * @returns An instance of [`Attribute`](https://layrjs.com/docs/v1/reference/attribute).
     *
     * @example
     * ```
     * movie.getAttribute('title'); // => 'title' attribute property
     * movie.getAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    getAttribute(name: string, options?: {
        autoFork?: boolean;
    }): Attribute;
    /**
     * Returns whether the component has the specified attribute.
     *
     * @param name The name of the attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasAttribute('title'); // => true
     * movie.hasAttribute('name'); // => false
     * movie.hasAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    static get hasAttribute(): (name: string) => boolean;
    /**
     * Returns whether the component has the specified attribute.
     *
     * @param name The name of the attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasAttribute('title'); // => true
     * movie.hasAttribute('name'); // => false
     * movie.hasAttribute('play'); // => Error ('play' is a method)
     * ```
     *
     * @category Attribute Properties
     */
    hasAttribute(name: string): boolean;
    static get __getAttribute(): (name: string, options: {
        autoFork: boolean;
    }) => Attribute | undefined;
    __getAttribute(name: string, options: {
        autoFork: boolean;
    }): Attribute | undefined;
    /**
     * Defines an attribute in the component. Typically, instead of using this method, you would rather use the [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) decorator.
     *
     * @param name The name of the attribute to define.
     * @param [attributeOptions] The options to create the [`Attribute`](https://layrjs.com/docs/v1/reference/attribute#constructor).
     *
     * @returns The [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setAttribute('title', {valueType: 'string'});
     * ```
     *
     * @category Attribute Properties
     */
    static get setAttribute(): (name: string, attributeOptions?: AttributeOptions) => Attribute;
    /**
     * Defines an attribute in the component. Typically, instead of using this method, you would rather use the [`@attribute()`](https://layrjs.com/docs/v1/reference/component#attribute-decorator) decorator.
     *
     * @param name The name of the attribute to define.
     * @param [attributeOptions] The options to create the [`Attribute`](https://layrjs.com/docs/v1/reference/attribute#constructor).
     *
     * @returns The [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setAttribute('title', {valueType: 'string'});
     * ```
     *
     * @category Attribute Properties
     */
    setAttribute(name: string, attributeOptions?: AttributeOptions): Attribute;
    /**
     * Returns an iterator providing the attributes of the component.
     *
     * @param [options.filter] A function used to filter the attributes to be returned. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     *
     * @returns An [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance iterator.
     *
     * @example
     * ```
     * for (const attr of movie.getAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // title
     * ```
     *
     * @category Attribute Properties
     */
    static get getAttributes(): <AttributeType extends Attribute = Attribute>(options?: {
        filter?: PropertyFilterSync | undefined;
        autoFork?: boolean | undefined;
    } & CreatePropertyFilterOptionsForAttributes) => {
        [Symbol.iterator](): Generator<AttributeType, void, unknown>;
    };
    /**
     * Returns an iterator providing the attributes of the component.
     *
     * @param [options.filter] A function used to filter the attributes to be returned. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be returned (default: `true`, which means that all the attributes should be returned).
     *
     * @returns An [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance iterator.
     *
     * @example
     * ```
     * for (const attr of movie.getAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // title
     * ```
     *
     * @category Attribute Properties
     */
    getAttributes<AttributeType extends Attribute = Attribute>(options?: {
        filter?: PropertyFilterSync;
        autoFork?: boolean;
    } & CreatePropertyFilterOptionsForAttributes): {
        [Symbol.iterator](): Generator<AttributeType, void, unknown>;
    };
    static get traverseAttributes(): (iteratee: TraverseAttributesIteratee, options?: Partial<TraverseAttributesOptions> & ResolveAttributeSelectorOptions) => void;
    traverseAttributes(iteratee: TraverseAttributesIteratee, options?: Partial<TraverseAttributesOptions> & ResolveAttributeSelectorOptions): void;
    static get __traverseAttributes(): (iteratee: TraverseAttributesIteratee, { attributeSelector, setAttributesOnly }: TraverseAttributesOptions) => void;
    __traverseAttributes(iteratee: TraverseAttributesIteratee, { attributeSelector, setAttributesOnly }: TraverseAttributesOptions): void;
    /**
     * Gets an identifier attribute of the component.
     *
     * @param name The name of the identifier attribute to get.
     *
     * @returns An instance of [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) or [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute).
     *
     * @example
     * ```
     * movie.getIdentifierAttribute('id'); // => 'id' primary identifier attribute
     * movie.getIdentifierAttribute('slug'); // => 'slug' secondary identifier attribute
     * ```
     *
     * @category Attribute Properties
     */
    getIdentifierAttribute(name: string, options?: {
        autoFork?: boolean;
    }): IdentifierAttribute;
    /**
     * Returns whether the component has the specified identifier attribute.
     *
     * @param name The name of the identifier attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasIdentifierAttribute('id'); // => true
     * movie.hasIdentifierAttribute('slug'); // => true
     * movie.hasIdentifierAttribute('name'); // => false (the property 'name' doesn't exist)
     * movie.hasIdentifierAttribute('title'); // => Error ('title' is not an identifier attribute)
     * ```
     *
     * @category Attribute Properties
     */
    hasIdentifierAttribute(name: string): boolean;
    __getIdentifierAttribute(name: string, options: {
        autoFork: boolean;
    }): IdentifierAttribute | undefined;
    /**
     * Gets the primary identifier attribute of the component.
     *
     * @returns An instance of [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute).
     *
     * @example
     * ```
     * movie.getPrimaryIdentifierAttribute(); // => 'id' primary identifier attribute
     * ```
     *
     * @category Attribute Properties
     */
    getPrimaryIdentifierAttribute(options?: {
        autoFork?: boolean;
    }): PrimaryIdentifierAttribute;
    /**
     * Returns whether the component as a primary identifier attribute.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasPrimaryIdentifierAttribute(); // => true
     * ```
     *
     * @category Attribute Properties
     */
    hasPrimaryIdentifierAttribute(): boolean;
    __getPrimaryIdentifierAttribute(options: {
        autoFork: boolean;
    }): PrimaryIdentifierAttribute | undefined;
    /**
     * Defines the primary identifier attribute of the component. Typically, instead of using this method, you would rather use the [`@primaryIdentifier()`](https://layrjs.com/docs/v1/reference/component#primary-identifier-decorator) decorator.
     *
     * @param name The name of the primary identifier attribute to define.
     * @param [attributeOptions] The options to create the [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute).
     *
     * @returns The [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) that was created.
     *
     * @example
     * ```
     * User.prototype.setPrimaryIdentifierAttribute('id', {
     *   valueType: 'number',
     *   default() {
     *     return Math.random();
     *   }
     * });
     * ```
     *
     * @category Attribute Properties
     */
    setPrimaryIdentifierAttribute(name: string, attributeOptions?: AttributeOptions): PrimaryIdentifierAttribute;
    /**
     * Gets a secondary identifier attribute of the component.
     *
     * @param name The name of the secondary identifier attribute to get.
     *
     * @returns A [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) instance.
     *
     * @example
     * ```
     * movie.getSecondaryIdentifierAttribute('slug'); // => 'slug' secondary identifier attribute
     * movie.getSecondaryIdentifierAttribute('id'); // => Error ('id' is not a secondary identifier attribute)
     * ```
     *
     * @category Attribute Properties
     */
    getSecondaryIdentifierAttribute(name: string, options?: {
        autoFork?: boolean;
    }): SecondaryIdentifierAttribute;
    /**
     * Returns whether the component has the specified secondary identifier attribute.
     *
     * @param name The name of the secondary identifier attribute to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasSecondaryIdentifierAttribute('slug'); // => true
     * movie.hasSecondaryIdentifierAttribute('name'); // => false (the property 'name' doesn't exist)
     * movie.hasSecondaryIdentifierAttribute('id'); // => Error ('id' is not a secondary identifier attribute)
     * ```
     *
     * @category Attribute Properties
     */
    hasSecondaryIdentifierAttribute(name: string): boolean;
    __getSecondaryIdentifierAttribute(name: string, options: {
        autoFork: boolean;
    }): SecondaryIdentifierAttribute | undefined;
    /**
     * Defines a secondary identifier attribute in the component. Typically, instead of using this method, you would rather use the [`@secondaryIdentifier()`](https://layrjs.com/docs/v1/reference/component#secondary-identifier-decorator) decorator.
     *
     * @param name The name of the secondary identifier attribute to define.
     * @param [attributeOptions] The options to create the [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute).
     *
     * @returns The [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) that was created.
     *
     * @example
     * ```
     * User.prototype.setSecondaryIdentifierAttribute('slug', {valueType: 'string'});
     * ```
     *
     * @category Attribute Properties
     */
    setSecondaryIdentifierAttribute(name: string, attributeOptions?: AttributeOptions): SecondaryIdentifierAttribute;
    /**
     * Returns an iterator providing the identifier attributes of the component.
     *
     * @param [options.filter] A function used to filter the identifier attributes to be returned. The function is invoked for each identifier attribute with an `IdentifierAttribute` instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set identifier attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the identifier attributes to be returned (default: `true`, which means that all identifier attributes should be returned).
     *
     * @returns An iterator of [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) or [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute).
     *
     * @example
     * ```
     * for (const attr of movie.getIdentifierAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // id
     * // slug
     * ```
     *
     * @category Attribute Properties
     */
    getIdentifierAttributes(options?: {
        filter?: PropertyFilterSync;
        autoFork?: boolean;
    } & CreatePropertyFilterOptionsForAttributes): {
        [Symbol.iterator](): Generator<IdentifierAttribute, void, unknown>;
    };
    /**
     * Returns an iterator providing the secondary identifier attributes of the component.
     *
     * @param [options.filter] A function used to filter the secondary identifier attributes to be returned. The function is invoked for each identifier attribute with a [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) instance as first argument.
     * @param [options.setAttributesOnly] A boolean specifying whether only set secondary identifier attributes should be returned (default: `false`).
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the secondary identifier attributes to be returned (default: `true`, which means that all secondary identifier attributes should be returned).
     *
     * @returns A [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) instance iterator.
     *
     * @example
     * ```
     * for (const attr of movie.getSecondaryIdentifierAttributes()) {
     *   console.log(attr.getName());
     * }
     *
     * // Should output:
     * // slug
     * ```
     *
     * @category Attribute Properties
     */
    getSecondaryIdentifierAttributes(options?: {
        filter?: PropertyFilterSync;
        autoFork?: boolean;
    } & CreatePropertyFilterOptionsForAttributes): {
        [Symbol.iterator](): Generator<SecondaryIdentifierAttribute, void, unknown>;
    };
    /**
     * Returns an object composed of all the set identifiers of the component. The shape of the returned object is `{[identifierName]: identifierValue}`. If the component doesn't have any set identifiers, returns `undefined`.
     *
     * @returns An object.
     *
     * @example
     * ```
     * movie.getIdentifiers(); // => {id: 'abc123', slug: 'inception'}
     * ```
     *
     * @category Attribute Properties
     */
    getIdentifiers(): IdentifierObject;
    /**
     * Returns whether the component has a set identifier or not.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasIdentifiers(); // => true
     * ```
     *
     * @category Attribute Properties
     */
    hasIdentifiers(): boolean;
    __getIdentifiers(): IdentifierObject | undefined;
    /**
     * Generates a unique identifier using the [cuid](https://github.com/ericelliott/cuid) library.
     *
     * @returns The generated identifier.
     *
     * @example
     * ```
     * Movie.generateId(); // => 'ck41vli1z00013h5xx1esffyn'
     * ```
     *
     * @category Attribute Properties
     */
    static generateId(): string;
    __partitionAttributes(object: PlainObject): {
        identifierAttributes: PlainObject;
        otherAttributes: PlainObject;
    };
    __getMinimumAttributeCount(): 1 | 0;
    /**
     * Returns the `IdentifierDescriptor` of the component.
     *
     * An `IdentifierDescriptor` is a plain object composed of one pair of name/value corresponding to the name and value of the first identifier attribute encountered in a component. Usually it is the primary identifier, but if the latter is not set, it can be a secondary identifier.
     *
     * If there is no set identifier in the component, an error is thrown.
     *
     * @returns An object.
     *
     * @example
     * ```
     * movie.getIdentifierDescriptor(); // => {id: 'abc123'}
     * ```
     *
     * @category Identifier Descriptor
     */
    getIdentifierDescriptor(): NormalizedIdentifierDescriptor;
    /**
     * Returns whether the component can provide an `IdentifierDescriptor` (using the [`getIdentifierDescriptor()`](https://layrjs.com/docs/v1/reference/component#get-identifier-descriptor-instance-method) method) or not.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasIdentifierDescriptor(); // => true
     * ```
     *
     * @category Identifier Descriptor
     */
    hasIdentifierDescriptor(): boolean;
    __getIdentifierDescriptor(): NormalizedIdentifierDescriptor | undefined;
    static normalizeIdentifierDescriptor(identifierDescriptor: IdentifierDescriptor): NormalizedIdentifierDescriptor;
    static describeIdentifierDescriptor(identifierDescriptor: IdentifierDescriptor): string;
    static __identityMap: IdentityMap;
    /**
     * Gets the [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map) of the component.
     *
     * @returns An [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map) instance.
     *
     * @category Identity Mapping
     */
    static getIdentityMap(): IdentityMap;
    static __isAttached: boolean;
    /**
     * Attaches the component class to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map). By default, all component classes are attached, so unless you have detached a component class earlier, you should not have to use this method.
     *
     * @returns The component class.
     *
     * @category Identity Mapping
     */
    static attach<T extends typeof Component>(this: T): T;
    /**
     * Detaches the component class from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns The component class.
     *
     * @category Identity Mapping
     */
    static detach<T extends typeof Component>(this: T): T;
    /**
     * Returns whether the component class is attached to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    static isAttached(): boolean;
    /**
     * Returns whether the component class is detached from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    static isDetached(): boolean;
    __isAttached?: boolean;
    /**
     * Attaches the component instance to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map). By default, all component instances are attached, so unless you have detached a component instance earlier, you should not have to use this method.
     *
     * @returns The component instance.
     *
     * @category Identity Mapping
     */
    attach(): this;
    /**
     * Detaches the component instance from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns The component instance.
     *
     * @category Identity Mapping
     */
    detach(): this;
    /**
     * Returns whether the component instance is attached to its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    isAttached(): boolean;
    /**
     * Returns whether the component instance is detached from its [`IdentityMap`](https://layrjs.com/docs/v1/reference/identity-map).
     *
     * @returns A boolean.
     *
     * @category Identity Mapping
     */
    isDetached(): boolean;
    static get resolveAttributeSelector(): (attributeSelector: AttributeSelector, options?: ResolveAttributeSelectorOptions) => AttributeSelector;
    resolveAttributeSelector(attributeSelector: AttributeSelector, options?: ResolveAttributeSelectorOptions): AttributeSelector;
    static get __resolveAttributeSelector(): (attributeSelector: AttributeSelector, options: ResolveAttributeSelectorOptions) => AttributeSelector;
    __resolveAttributeSelector(attributeSelector: AttributeSelector, options: ResolveAttributeSelectorOptions): AttributeSelector;
    /**
     * Validates the attributes of the component. If an attribute doesn't pass the validation, an error is thrown. The error is a JavaScript `Error` instance with a `failedValidators` custom attribute which contains the result of the [`runValidators()`](https://layrjs.com/docs/v1/reference/component#run-validators-dual-method) method.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @example
     * ```
     * // JS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title!: string;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @category Validation
     */
    static get validate(): (attributeSelector?: AttributeSelector) => void;
    /**
     * Validates the attributes of the component. If an attribute doesn't pass the validation, an error is thrown. The error is a JavaScript `Error` instance with a `failedValidators` custom attribute which contains the result of the [`runValidators()`](https://layrjs.com/docs/v1/reference/component#run-validators-dual-method) method.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @example
     * ```
     * // JS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * import {Component, attribute, validators} from '﹫layr/component';
     *
     * const {notEmpty} = validators;
     *
     * class Movie extends Component {
     *   ﹫attribute('string', {validators: [notEmpty()]}) title!: string;
     * }
     *
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.title; // => 'Inception'
     * movie.validate(); // All good!
     * movie.title = '';
     * movie.validate(); // Error {failedValidators: [{validator: ..., path: 'title'}]}
     * ```
     *
     * @category Validation
     */
    validate(attributeSelector?: AttributeSelector): void;
    /**
     * Returns whether the attributes of the component are valid.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be checked (default: `true`, which means that all the attributes will be checked).
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.isValid(); // => true
     * movie.title = '';
     * movie.isValid(); // => false
     * ```
     *
     * @category Validation
     */
    static get isValid(): (attributeSelector?: AttributeSelector) => boolean;
    /**
     * Returns whether the attributes of the component are valid.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be checked (default: `true`, which means that all the attributes will be checked).
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.isValid(); // => true
     * movie.title = '';
     * movie.isValid(); // => false
     * ```
     *
     * @category Validation
     */
    isValid(attributeSelector?: AttributeSelector): boolean;
    /**
     * Runs the validators for all the set attributes of the component.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @returns An array containing the validators that have failed. Each item is a plain object composed of a `validator` (a [`Validator`](https://layrjs.com/docs/v1/reference/validator) instance) and a `path` (a string representing the path of the attribute containing the validator that has failed).
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.runValidators(); // => []
     * movie.title = '';
     * movie.runValidators(); // => [{validator: ..., path: 'title'}]
     * ```
     *
     * @category Validation
     */
    static get runValidators(): (attributeSelector?: AttributeSelector) => {
        validator: import("./validation").Validator;
        path: string;
    }[];
    /**
     * Runs the validators for all the set attributes of the component.
     *
     * @param [attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be validated (default: `true`, which means that all the attributes will be validated).
     *
     * @returns An array containing the validators that have failed. Each item is a plain object composed of a `validator` (a [`Validator`](https://layrjs.com/docs/v1/reference/validator) instance) and a `path` (a string representing the path of the attribute containing the validator that has failed).
     *
     * @example
     * ```
     * // See the `movie` definition in the `validate()` example
     *
     * movie.title; // => 'Inception'
     * movie.runValidators(); // => []
     * movie.title = '';
     * movie.runValidators(); // => [{validator: ..., path: 'title'}]
     * ```
     *
     * @category Validation
     */
    runValidators(attributeSelector?: AttributeSelector): {
        validator: import("./validation").Validator;
        path: string;
    }[];
    /**
     * Gets a method of the component.
     *
     * @param name The name of the method to get.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance.
     *
     * @example
     * ```
     * movie.getMethod('play'); // => 'play' method property
     * movie.getMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    static get getMethod(): (name: string, options?: {
        autoFork?: boolean | undefined;
    }) => Method;
    /**
     * Gets a method of the component.
     *
     * @param name The name of the method to get.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance.
     *
     * @example
     * ```
     * movie.getMethod('play'); // => 'play' method property
     * movie.getMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    getMethod(name: string, options?: {
        autoFork?: boolean;
    }): Method;
    /**
     * Returns whether the component has the specified method.
     *
     * @param name The name of the method to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasMethod('play'); // => true
     * movie.hasMethod('destroy'); // => false
     * movie.hasMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    static get hasMethod(): (name: string) => boolean;
    /**
     * Returns whether the component has the specified method.
     *
     * @param name The name of the method to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * movie.hasMethod('play'); // => true
     * movie.hasMethod('destroy'); // => false
     * movie.hasMethod('title'); // => Error ('title' is an attribute property)
     * ```
     *
     * @category Method Properties
     */
    hasMethod(name: string): boolean;
    static get __getMethod(): (name: string, options: {
        autoFork: boolean;
    }) => Method | undefined;
    __getMethod(name: string, options: {
        autoFork: boolean;
    }): Method | undefined;
    /**
     * Defines a method in the component. Typically, instead of using this method, you would rather use the [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator) decorator.
     *
     * @param name The name of the method to define.
     * @param [methodOptions] The options to create the [`Method`](https://layrjs.com/docs/v1/reference/method#constructor).
     *
     * @returns The [`Method`](https://layrjs.com/docs/v1/reference/method) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setMethod('play');
     * ```
     *
     * @category Method Properties
     */
    static get setMethod(): (name: string, methodOptions?: PropertyOptions) => Method;
    /**
     * Defines a method in the component. Typically, instead of using this method, you would rather use the [`@method()`](https://layrjs.com/docs/v1/reference/component#method-decorator) decorator.
     *
     * @param name The name of the method to define.
     * @param [methodOptions] The options to create the [`Method`](https://layrjs.com/docs/v1/reference/method#constructor).
     *
     * @returns The [`Method`](https://layrjs.com/docs/v1/reference/method) that was created.
     *
     * @example
     * ```
     * Movie.prototype.setMethod('play');
     * ```
     *
     * @category Method Properties
     */
    setMethod(name: string, methodOptions?: MethodOptions): Method;
    /**
     * Returns an iterator providing the methods of the component.
     *
     * @param [options.filter] A function used to filter the methods to be returned. The function is invoked for each method with a [`Method`](https://layrjs.com/docs/v1/reference/method) instance as first argument.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance iterator.
     *
     * @example
     * ```
     * for (const meth of movie.getMethods()) {
     *   console.log(meth.getName());
     * }
     *
     * // Should output:
     * // play
     * ```
     *
     * @category Method Properties
     */
    static get getMethods(): (options?: {
        filter?: PropertyFilterSync | undefined;
        autoFork?: boolean | undefined;
    }) => {
        [Symbol.iterator](): Generator<Method, void, unknown>;
    };
    /**
     * Returns an iterator providing the methods of the component.
     *
     * @param [options.filter] A function used to filter the methods to be returned. The function is invoked for each method with a [`Method`](https://layrjs.com/docs/v1/reference/method) instance as first argument.
     *
     * @returns A [`Method`](https://layrjs.com/docs/v1/reference/method) instance iterator.
     *
     * @example
     * ```
     * for (const meth of movie.getMethods()) {
     *   console.log(meth.getName());
     * }
     *
     * // Should output:
     * // play
     * ```
     *
     * @category Method Properties
     */
    getMethods(options?: {
        filter?: PropertyFilterSync;
        autoFork?: boolean;
    }): {
        [Symbol.iterator](): Generator<Method, void, unknown>;
    };
    /**
     * Gets a component class that is provided or consumed by the current component. An error is thrown if there is no component matching the specified name. If the specified name is the name of the current component, the latter is returned.
     *
     * @param name The name of the component class to get.
     *
     * @returns A component class.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.getComponent('Movie'); // => Movie
     * Backend.getComponent('Backend'); // => Backend
     * ```
     *
     * @category Dependency Management
     */
    static getComponent(name: string): typeof Component;
    /**
     * Returns whether the current component provides or consumes another component.
     *
     * @param name The name of the component class to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.hasComponent('Movie'); // => true
     * Backend.hasComponent('Backend'); // => true
     * Backend.hasComponent('Film'); // => false
     * ```
     *
     * @category Dependency Management
     */
    static hasComponent(name: string): boolean;
    static __getComponent(name: string): typeof Component | undefined;
    /**
     * Gets a component class or prototype of the specified type that is provided or consumed by the current component. An error is thrown if there is no component matching the specified type. If the specified type is the type of the current component, the latter is returned.
     *
     * @param type The type of the component class or prototype to get.
     *
     * @returns A component class or prototype.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.getComponentOfType('typeof Movie'); // => Movie
     * Backend.getComponentOfType('Movie'); // => Movie.prototype
     * Backend.getComponentOfType('typeof Backend'); // => Backend
     * Backend.getComponentOfType('Backend'); // => Backend.prototype
     * ```
     *
     * @category Dependency Management
     */
    static getComponentOfType(type: string): typeof Component | Component;
    /**
     * Returns whether the current component provides or consumes a component class or prototype matching the specified type.
     *
     * @param type The type of the component class or prototype to check.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.hasComponentOfType('typeof Movie'); // => true
     * Backend.hasComponentOfType('Movie'); // => true
     * Backend.hasComponentOfType('typeof Backend'); // => true
     * Backend.hasComponentOfType('Backend'); // => true
     * Backend.hasComponentOfType('typeof Film'); // => false
     * Backend.hasComponentOfType('Film'); // => false
     * ```
     *
     * @category Dependency Management
     */
    static hasComponentOfType(type: string): boolean;
    static __getComponentOfType(type: string): typeof Component | Component | undefined;
    /**
     * Gets a component that is provided by the current component. An error is thrown if there is no provided component with the specified name.
     *
     * @param name The name of the provided component to get.
     *
     * @returns A component class.
     *
     * @example
     * ```
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     * }
     *
     * Backend.getProvidedComponent('Movie'); // => Movie
     * ```
     *
     * @category Dependency Management
     */
    static getProvidedComponent(name: string): typeof Component | undefined;
    /**
     * Specifies that the current component is providing another component so it can be easily accessed from the current component or from any component that is "consuming" it using the [`consumeComponent()`](https://layrjs.com/docs/v1/reference/component#consume-component-class-method) method or the [`@consume()`](https://layrjs.com/docs/v1/reference/component#consume-decorator) decorator.
     *
     * The provided component can later be accessed using a component accessor that was automatically set on the component provider.
     *
     * Typically, instead of using this method, you would rather use the [`@provide()`]((https://layrjs.com/docs/v1/reference/component#provide-decorator)) decorator.
     *
     * @param component The component class to provide.
     *
     * @example
     * ```
     * class Backend extends Component {}
     * class Movie extends Component {}
     * Backend.provideComponent(Movie);
     *
     * Backend.Movie; // => `Movie` class
     * ```
     *
     * @category Dependency Management
     */
    static provideComponent(component: typeof Component): void;
    /**
     * Returns an iterator allowing to iterate over the components provided by the current component.
     *
     * @param [options.filter] A function used to filter the provided components to be returned. The function is invoked for each provided component with the provided component as first argument.
     * @param [options.deep] A boolean specifying whether the method should get the provided components recursively (i.e., get the provided components of the provided components). Default: `false`.
     *
     * @returns A component iterator.
     *
     * @category Dependency Management
     */
    static getProvidedComponents(options?: {
        deep?: boolean;
        filter?: (providedComponent: typeof Component) => boolean;
    }): {
        [Symbol.iterator](): Generator<typeof Component>;
    };
    /**
     * Returns the provider of the component. If there is no component provider, returns the current component.
     *
     * @returns A component provider.
     *
     * @example
     * ```
     * class Backend extends Component {}
     * class Movie extends Component {}
     * Backend.provideComponent(Movie);
     *
     * Movie.getComponentProvider(); // => `Backend` class
     * Backend.getComponentProvider(); // => `Backend` class
     * ```
     *
     * @category Dependency Management
     */
    static getComponentProvider(): typeof Component;
    static __componentProvider?: typeof Component;
    static __getComponentProvider(): typeof Component | undefined;
    static __setComponentProvider(componentProvider: typeof Component): void;
    static __providedComponents: {
        [name: string]: typeof Component;
    };
    static __getProvidedComponents(): {
        [name: string]: typeof Component;
    };
    /**
     * Gets a component that is consumed by the current component. An error is thrown if there is no consumed component with the specified name. Typically, instead of using this method, you would rather use the component accessor that has been automatically set for you.
     *
     * @param name The name of the consumed component to get.
     *
     * @returns A component class.
     *
     * @example
     * ```
     * // JS
     *
     * class Movie extends Component {
     *   ﹫consume() static Actor;
     * }
     *
     * class Actor extends Component {}
     *
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     *   ﹫provide() static Actor = Actor;
     * }
     *
     * Movie.getConsumedComponent('Actor'); // => Actor
     *
     * // Typically, you would rather use the component accessor:
     * Movie.Actor; // => Actor
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * class Movie extends Component {
     *   ﹫consume() static Actor: typeof Actor;
     * }
     *
     * class Actor extends Component {}
     *
     * class Backend extends Component {
     *   ﹫provide() static Movie = Movie;
     *   ﹫provide() static Actor = Actor;
     * }
     *
     * Movie.getConsumedComponent('Actor'); // => Actor
     *
     * // Typically, you would rather use the component accessor:
     * Movie.Actor; // => Actor
     * ```
     *
     * @category Dependency Management
     */
    static getConsumedComponent(name: string): typeof Component | undefined;
    /**
     * Specifies that the current component is consuming another component so it can be easily accessed using a component accessor.
     *
     * Typically, instead of using this method, you would rather use the [`@consume()`]((https://layrjs.com/docs/v1/reference/component#consume-decorator)) decorator.
     *
     * @param name The name of the component to consume.
     *
     * @example
     * ```
     * class Backend extends Component {}
     * class Movie extends Component {}
     * Backend.provideComponent(Movie);
     * Movie.consumeComponent('Backend');
     *
     * Movie.Backend; // => `Backend` class
     * ```
     *
     * @category Dependency Management
     */
    static consumeComponent(name: string): void;
    /**
     * Returns an iterator allowing to iterate over the components consumed by the current component.
     *
     * @param [options.filter] A function used to filter the consumed components to be returned. The function is invoked for each consumed component with the consumed component as first argument.
     *
     * @returns A component iterator.
     *
     * @category Dependency Management
     */
    static getConsumedComponents(options?: {
        filter?: (consumedComponent: typeof Component) => boolean;
    }): {
        [Symbol.iterator](): Generator<typeof Component, void, unknown>;
    };
    static __consumedComponents: Set<string>;
    static __getConsumedComponents(autoFork?: boolean): Set<string>;
    static clone(): typeof Component;
    /**
     * Clones the component instance. All primitive attributes are copied, and embedded components are cloned recursively. Currently, identifiable components (i.e., components having an identifier attribute) cannot be cloned, but this might change in the future.
     *
     * @returns A clone of the component.
     *
     * @example
     * ```
     * movie.title = 'Inception';
     *
     * const movieClone = movie.clone();
     * movieClone.title = 'Inception 2';
     *
     * movieClone.title; // => 'Inception 2'
     * movie.title; // => 'Inception'
     * ```
     *
     * @category Cloning
     * @possiblyasync
     */
    clone<T extends Component, R = ReturnType<T['initialize']> extends PromiseLike<void> ? PromiseLike<T> : T>(this: T, options?: CloneOptions): R;
    /**
     * Creates a fork of the component class.
     *
     * @returns The component class fork.
     *
     * @example
     * ```
     * class Movie extends Component {}
     *
     * Movie.fork(); // => A fork of the `Movie` class
     * ```
     *
     * @category Forking
     */
    static fork<T extends typeof Component>(this: T, options?: ForkOptions): T;
    /**
     * Creates a fork of the component instance. Note that the constructor of the resulting component will be a fork of the component class.
     *
     * @returns The component instance fork.
     *
     * @example
     * ```
     * class Movie extends Component {}
     * const movie = new Movie();
     *
     * movie.fork(); // => A fork of `movie`
     * movie.fork().constructor.isForkOf(Movie); // => true
     * ```
     *
     * @category Forking
     */
    fork<T extends Component>(this: T, options?: ForkOptions): T;
    /**
     * Returns whether the component class is a fork of another component class.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Movie extends Component {}
     * const MovieFork = Movie.fork();
     *
     * MovieFork.isForkOf(Movie); // => true
     * Movie.isForkOf(MovieFork); // => false
     * ```
     *
     * @category Forking
     */
    static isForkOf(component: typeof Component): boolean;
    /**
     * Returns whether the component instance is a fork of another component instance.
     *
     * @returns A boolean.
     *
     * @example
     * ```
     * class Movie extends Component {}
     * const movie = new Movie();
     * const movieFork = movie.fork();
     *
     * movieFork.isForkOf(movie); // => true
     * movie.isForkOf(movieFork); // => false
     * ```
     *
     * @category Forking
     */
    isForkOf(component: Component): boolean;
    static [Symbol.hasInstance](instance: any): boolean;
    static __ghost: typeof Component;
    /**
     * Gets the ghost of the component class. A ghost is like a fork, but it is unique. The first time you call this method, a fork is created, and then, all the successive calls return the same fork.
     *
     * @returns The ghost of the component class.
     *
     * @example
     * ```
     * class Movie extends Component {}
     *
     * Movie.getGhost() // => A fork of the `Movie` class
     * Movie.getGhost() // => The same fork of the `Movie` class
     * ```
     *
     * @category Forking
     */
    static getGhost<T extends typeof Component>(this: T): T;
    /**
     * Gets the ghost of the component instance. A ghost is like a fork, but it is unique. The first time you call this method, a fork is created, and then, all the successive calls return the same fork. Only identifiable components (i.e., components having an identifier attribute) can be "ghosted".
     *
     * @returns The ghost of the component instance.
     *
     * @example
     * ```
     * // JS
     *
     * class Movie extends Component {
     *   ﹫primaryIdentifier() id;
     * }
     *
     * const movie = new Movie();
     *
     * movie.getGhost() // => A fork of `movie`
     * movie.getGhost() // => The same fork of `movie`
     * ```
     *
     * @example
     * ```
     * // TS
     *
     * class Movie extends Component {
     *   ﹫primaryIdentifier() id!: string;
     * }
     *
     * const movie = new Movie();
     *
     * movie.getGhost() // => A fork of `movie`
     * movie.getGhost() // => The same fork of `movie`
     * ```
     *
     * @category Forking
     */
    getGhost<T extends Component>(this: T): T;
    /**
     * Merges the attributes of a component class fork into the current component class.
     *
     * @param forkedComponent The component class fork to merge.
     *
     * @returns The current component class.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') static customName = 'Movie';
     * }
     *
     * const MovieFork = Movie.fork();
     * MovieFork.customName = 'Film';
     *
     * Movie.customName; // => 'Movie'
     * Movie.merge(MovieFork);
     * Movie.customName; // => 'Film'
     * ```
     *
     * @category Merging
     */
    static merge<T extends typeof Component>(this: T, forkedComponent: typeof Component, options?: MergeOptions): T;
    /**
     * Merges the attributes of a component instance fork into the current component instance.
     *
     * @param forkedComponent The component instance fork to merge.
     *
     * @returns The current component instance.
     *
     * @example
     * ```
     * const movie = new Movie({title: 'Inception'});
     * const movieFork = movie.fork();
     * movieFork.title = 'Inception 2';
     *
     * movie.title; // => 'Inception'
     * movie.merge(movieFork);
     * movie.title; // => 'Inception 2'
     * ```
     *
     * @category Merging
     */
    merge(forkedComponent: Component, options?: MergeOptions): this;
    static get __mergeAttributes(): (forkedComponent: typeof Component | Component, options: MergeOptions) => void;
    __mergeAttributes(forkedComponent: typeof Component | Component, options: MergeOptions): void;
    /**
     * Serializes the component class to a plain object.
     *
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be serialized (default: `true`, which means that all the attributes will be serialized).
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be serialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.target] A number specifying the [target](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `undefined`).
     *
     * @returns A plain object representing the serialized component class.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') static customName = 'Film';
     * }
     *
     * Movie.serialize(); // => {__component: 'typeof Movie', customName: 'Film'}
     * ```
     *
     * @category Serialization
     * @possiblyasync
     */
    static serialize(options?: SerializeOptions): PlainObject | undefined;
    static __serialize(options: SerializeOptions): PlainObject | undefined;
    /**
     * Serializes the component instance to a plain object.
     *
     * @param [options.attributeSelector] An [`AttributeSelector`](https://layrjs.com/docs/v1/reference/attribute-selector) specifying the attributes to be serialized (default: `true`, which means that all the attributes will be serialized).
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be serialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.target] A number specifying the [target](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `undefined`).
     *
     * @returns A plain object representing the serialized component instance.
     *
     * @example
     * ```
     * const movie = new Movie({title: 'Inception'});
     *
     * movie.serialize(); // => {__component: 'Movie', title: 'Inception'}
     * ```
     *
     * @category Serialization
     * @possiblyasync
     */
    serialize(options?: SerializeOptions): PlainObject | undefined;
    __serialize(options: SerializeOptions): PlainObject | undefined;
    static get __serializeAttributes(): (serializedComponent: PlainObject, options: SerializeOptions) => PromiseLikeable<number>;
    __serializeAttributes(serializedComponent: PlainObject, options: SerializeOptions): PromiseLikeable<number>;
    /**
     * Recreates a component instance from the result of its serialization.
     *
     * @param [object] A plain object representing a serialized component.
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be deserialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `0`).
     *
     * @returns A component instance.
     *
     * @example
     * ```
     * const movie = Movie.recreate({title: 'Inception'});
     * movie.title; // => 'Inception'
     * ```
     *
     * @category Deserialization
     * @possiblyasync
     */
    static recreate<T extends typeof Component>(this: T, object?: PlainObject, options?: DeserializeOptions): InstanceType<T> | PromiseLike<InstanceType<T>>;
    /**
     * Deserializes the component class from the specified plain object. The deserialization operates "in place", which means that the current component class attributes are mutated.
     *
     * @param [object] The plain object to deserialize from.
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be deserialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `0`).
     *
     * @returns The component class.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') static customName = 'Movie';
     * }
     *
     * Movie.customName; // => 'Movie'
     * Movie.deserialize({customName: 'Film'});
     * Movie.customName; // => 'Film'
     * ```
     *
     * @category Deserialization
     * @possiblyasync
     */
    static deserialize<T extends typeof Component>(this: T, object?: PlainObject, options?: DeserializeOptions): T | PromiseLike<T>;
    /**
     * Deserializes the component instance from the specified plain object. The deserialization operates "in place", which means that the current component instance attributes are mutated.
     *
     * @param [object] The plain object to deserialize from.
     * @param [options.attributeFilter] A (possibly async) function used to filter the attributes to be deserialized. The function is invoked for each attribute with an [`Attribute`](https://layrjs.com/docs/v1/reference/attribute) instance as first argument.
     * @param [options.source] A number specifying the [source](https://layrjs.com/docs/v1/reference/attribute#value-source-type) of the serialization (default: `0`).
     *
     * @returns The current component instance.
     *
     * @example
     * ```
     * class Movie extends Component {
     *   ﹫attribute('string') title = '';
     * }
     *
     * const movie = new Movie();
     *
     * movie.title; // => ''
     * movie.deserialize({title: 'Inception'});
     * movie.title; // => 'Inception'
     * ```
     *
     * @category Deserialization
     * @possiblyasync
     */
    deserialize<T extends Component>(this: T, object?: PlainObject, options?: DeserializeOptions): T | PromiseLike<T>;
    static get __deserializeAttributes(): (serializedAttributes: PlainObject, options: DeserializeOptions) => void | PromiseLike<void>;
    __deserializeAttributes(serializedAttributes: PlainObject, options: DeserializeOptions): void | PromiseLike<void>;
    static get __deserializeAttribute(): (attribute: Attribute, serializedAttributeValue: unknown, componentGetter: ComponentGetter, options: DeserializeOptions) => void | PromiseLike<void>;
    __deserializeAttribute(attribute: Attribute, serializedAttributeValue: unknown, componentGetter: ComponentGetter, options: DeserializeOptions): void | PromiseLike<void>;
    static introspect({ _introspectedComponents }?: {
        _introspectedComponents?: IntrospectedComponentMap;
    }): IntrospectedComponent | undefined;
    static __introspectMixins(): string[];
    static get __introspectProperties(): () => IntrospectedProperty[];
    __introspectProperties(): IntrospectedProperty[];
    static __introspectProvidedComponents({ _introspectedComponents }: {
        _introspectedComponents: IntrospectedComponentMap;
    }): IntrospectedComponent[];
    static __introspectConsumedComponents({ _introspectedComponents }: {
        _introspectedComponents: IntrospectedComponentMap;
    }): string[];
    static unintrospect(introspectedComponent: IntrospectedComponent, options?: {
        mixins?: ComponentMixin[];
        methodBuilder?: MethodBuilder;
    }): typeof Component;
    static __unintrospectMixins(introspectedMixins: string[], { mixins }: {
        mixins: ComponentMixin[];
    }): typeof Component;
    static get __unintrospectProperties(): (introspectedProperties: IntrospectedProperty[], propertyClassGetter: typeof Component.getPropertyClass, { methodBuilder }: {
        methodBuilder: MethodBuilder | undefined;
    }) => void;
    __unintrospectProperties(introspectedProperties: IntrospectedProperty[], propertyClassGetter: typeof Component['getPropertyClass'], { methodBuilder }: {
        methodBuilder: MethodBuilder | undefined;
    }): void;
    static __unintrospectProvidedComponents(introspectedProvidedComponents: IntrospectedComponent[], { mixins, methodBuilder }: {
        mixins: ComponentMixin[] | undefined;
        methodBuilder: MethodBuilder | undefined;
    }): void;
    static __unintrospectConsumedComponents(introspectedConsumedComponents: string[]): void;
    static __remoteComponent: typeof Component | undefined;
    static getRemoteComponent(): typeof Component | undefined;
    getRemoteComponent(): Component | undefined;
    static __setRemoteComponent(remoteComponent: typeof Component): void;
    static get hasRemoteMethod(): (name: string) => boolean;
    hasRemoteMethod(name: string): boolean;
    static get callRemoteMethod(): (name: string, ...args: any[]) => any;
    callRemoteMethod(name: string, ...args: any[]): any;
    static __remoteMethodBuilder: MethodBuilder | undefined;
    static __setRemoteMethodBuilder(methodBuilder: MethodBuilder): void;
    static isComponent(value: any): value is Component;
    static get toObject(): (options?: {
        minimize?: boolean | undefined;
    }) => PlainObject;
    toObject(options?: {
        minimize?: boolean;
    }): PlainObject;
    static get describeComponent(): (options?: {
        componentPrefix?: string | undefined;
    }) => string;
    describeComponent(options?: {
        componentPrefix?: string;
    }): string;
    static describeComponentProperty(name: string): string;
    describeComponentProperty(name: string): string;
}
declare type CreatePropertyFilterOptions = {
    attributesOnly?: boolean;
    methodsOnly?: boolean;
} & CreatePropertyFilterOptionsForAttributes;
declare type CreatePropertyFilterOptionsForAttributes = {
    attributeSelector?: AttributeSelector;
    setAttributesOnly?: boolean;
};
export {};
