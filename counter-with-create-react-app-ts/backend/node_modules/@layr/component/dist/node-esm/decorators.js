import { hasOwnProperty, getPropertyDescriptor } from 'core-helpers';
import { Attribute, PrimaryIdentifierAttribute, SecondaryIdentifierAttribute, Method } from './properties';
import { isComponentClassOrInstance, isComponentClass, isComponentInstance } from './utilities';
import { getConstructorSourceCode, getAttributeInitializerFromConstructorSourceCode } from './js-parser';
export function attribute(valueType, options) {
    return createAttributeDecorator(new Map([[isComponentClassOrInstance, Attribute]]), 'attribute', valueType, options);
}
export function primaryIdentifier(valueType, options) {
    return createAttributeDecorator(new Map([[isComponentInstance, PrimaryIdentifierAttribute]]), 'primaryIdentifier', valueType, options);
}
export function secondaryIdentifier(valueType, options) {
    return createAttributeDecorator(new Map([[isComponentInstance, SecondaryIdentifierAttribute]]), 'secondaryIdentifier', valueType, options);
}
export function createAttributeDecorator(AttributeClassMap, decoratorName, valueType, options = {}) {
    if (typeof valueType === 'string') {
        options = { ...options, valueType };
    }
    else if (valueType !== undefined) {
        options = valueType;
    }
    if ('value' in options || 'default' in options) {
        throw new Error(`The options 'value' and 'default' are not authorized in @${decoratorName}()`);
    }
    let attributeOptions = options;
    return function (target, name, descriptor) {
        if (!isComponentClassOrInstance(target)) {
            throw new Error(`@${decoratorName}() must be used inside a component class (property: '${name}')`);
        }
        if (isComponentClass(target)) {
            const value = !target.hasAttribute(name) || target.getAttribute(name).isSet()
                ? target[name]
                : undefined;
            attributeOptions = { value, ...attributeOptions };
        }
        else {
            const initializer = getAttributeInitializer(target, name, descriptor);
            if (initializer !== undefined) {
                attributeOptions = { default: initializer, ...attributeOptions };
            }
        }
        const AttributeClass = getPropertyClass(AttributeClassMap, target, {
            decoratorName,
            propertyName: name
        });
        const attribute = target.setProperty(name, AttributeClass, attributeOptions);
        const compiler = determineCompiler(descriptor);
        if (compiler === 'typescript' && 'default' in attributeOptions) {
            if (attribute._isDefaultSetInConstructor) {
                throw new Error(`Cannot set a default value to an attribute that already has an inherited default value (property: '${name}')`);
            }
            attribute._isDefaultSetInConstructor = true;
        }
        if (compiler === 'babel-legacy') {
            return getPropertyDescriptor(target, name);
        }
    };
}
function getAttributeInitializer(component, attributeName, descriptor) {
    if (determineCompiler(descriptor) === 'babel-legacy') {
        return typeof descriptor.initializer === 'function' ? descriptor.initializer : undefined;
    }
    if (!hasOwnProperty(component, '__constructorSourceCode')) {
        const classSourceCode = component.constructor.toString();
        const constructorSourceCode = getConstructorSourceCode(classSourceCode);
        Object.defineProperty(component, '__constructorSourceCode', { value: constructorSourceCode });
    }
    const constructorSourceCode = component.__constructorSourceCode;
    if (constructorSourceCode === undefined) {
        return undefined;
    }
    return getAttributeInitializerFromConstructorSourceCode(constructorSourceCode, attributeName);
}
/**
 * Decorates a method of a component so it can be exposed and called remotely.
 *
 * @param [options] The options to create the [`Method`](https://layrjs.com/docs/v1/reference/method#constructor).
 *
 * @example
 * ```
 * import {Component, method} from '﹫layr/component';
 *
 * class Movie extends Component {
 *   // Class method
 *   ﹫method() static getConfig() {
 *     // ...
 *   }
 *
 *   // Instance method
 *   ﹫method() play() {
 *     // ...
 *   }
 * }
 * ```
 *
 * @category Decorators
 * @decorator
 */
export function method(options = {}) {
    return createMethodDecorator(new Map([[isComponentClassOrInstance, Method]]), 'method', options);
}
export function createMethodDecorator(MethodClassMap, decoratorName, options = {}) {
    return function (target, name, descriptor) {
        if (!isComponentClassOrInstance(target)) {
            throw new Error(`@${decoratorName}() must be used inside a component class (property: '${name}')`);
        }
        if (!(typeof descriptor.value === 'function' && descriptor.enumerable === false)) {
            throw new Error(`@${decoratorName}() must be used with a method declaration (property: '${name}')`);
        }
        const MethodClass = getPropertyClass(MethodClassMap, target, {
            decoratorName,
            propertyName: name
        });
        target.setProperty(name, MethodClass, options);
    };
}
function getPropertyClass(propertyClassMap, target, { decoratorName, propertyName }) {
    for (const [func, propertyClass] of propertyClassMap.entries()) {
        if (func(target)) {
            return propertyClass;
        }
    }
    throw new Error(`Couldn't find a property class while executing @${decoratorName}() (${target.describeComponent()}, property: '${propertyName}')`);
}
export function expose(exposure = {}) {
    return function (target, name) {
        if (name === undefined) {
            // Class decorator
            if (!isComponentClass(target)) {
                throw new Error(`@expose() must be used as a component class decorator or a component property decorator`);
            }
            const _expose = (target, exposures) => {
                for (const [name, exposure] of Object.entries(exposures)) {
                    target.getProperty(name).setExposure(exposure);
                }
            };
            const { prototype: prototypeExposure, ...classExposure } = exposure;
            _expose(target, classExposure);
            if (prototypeExposure !== undefined) {
                _expose(target.prototype, prototypeExposure);
            }
            return;
        }
        // Property decorator
        if (!isComponentClassOrInstance(target)) {
            throw new Error(`@expose() must be as a component class decorator or a component property decorator (property: '${name}')`);
        }
        if (!target.hasProperty(name) ||
            target.getProperty(name, { autoFork: false }).getParent() !== target) {
            throw new Error(`@expose() must be used in combination with @attribute() or @method() (property: '${name}')`);
        }
        target.getProperty(name).setExposure(exposure);
    };
}
/**
 * Provides a component so it can be easily accessed from the current component or from any component that is "consuming" it using the [`@consume()`](https://layrjs.com/docs/v1/reference/component#consume-decorator) decorator.
 *
 * @example
 * ```
 * // JS
 *
 * import {Component, provide, consume} from '﹫layr/component';
 *
 * class Movie extends Component {
 *   ﹫consume() static Actor;
 * }
 *
 * class Actor extends Component {}
 *
 * class Backend extends Component {
 *   ﹫provide() static Movie = Movie;
 *   ﹫provide() static Actor = Actor;
 * }
 *
 * // Since `Actor` is provided by `Backend`, it can be accessed from `Movie`
 * Movie.Actor; // => Actor
 * ```
 *
 * @example
 * ```
 * // TS
 *
 * import {Component, provide, consume} from '﹫layr/component';
 *
 * class Movie extends Component {
 *   ﹫consume() static Actor: typeof Actor;
 * }
 *
 * class Actor extends Component {}
 *
 * class Backend extends Component {
 *   ﹫provide() static Movie = Movie;
 *   ﹫provide() static Actor = Actor;
 * }
 *
 * // Since `Actor` is provided by `Backend`, it can be accessed from `Movie`
 * Movie.Actor; // => Actor
 * ```
 *
 * @category Decorators
 * @decorator
 */
export function provide() {
    return function (target, name, descriptor) {
        var _a;
        if (!isComponentClass(target)) {
            throw new Error(`@provide() must be used inside a component class with as static attribute declaration (attribute: '${name}')`);
        }
        const compiler = determineCompiler(descriptor);
        const component = (_a = Object.getOwnPropertyDescriptor(target, name)) === null || _a === void 0 ? void 0 : _a.value;
        if (!isComponentClass(component)) {
            throw new Error(`@provide() must be used with an attribute declaration specifying a component class (attribute: '${name}')`);
        }
        target.provideComponent(component);
        if (compiler === 'babel-legacy') {
            return getPropertyDescriptor(target, name);
        }
    };
}
/**
 * Consumes a component provided by the provider (or recursively, any provider's provider) of the current component so it can be easily accessed using a component accessor.
 *
 * @examplelink See [`@provide()`'s example](https://layrjs.com/docs/v1/reference/component#provide-decorator).
 *
 * @category Decorators
 * @decorator
 */
export function consume() {
    return function (target, name, descriptor) {
        if (!isComponentClass(target)) {
            throw new Error(`@consume() must be used inside a component class with as static attribute declaration (attribute: '${name}')`);
        }
        const compiler = determineCompiler(descriptor);
        if (hasOwnProperty(target, name)) {
            const propertyValue = target[name];
            if (propertyValue !== undefined) {
                throw new Error(`@consume() must be used with an attribute declaration which does not specify any value (attribute: '${name}')`);
            }
            if (compiler === 'babel-legacy') {
                delete target[name];
            }
        }
        target.consumeComponent(name);
        if (compiler === 'babel-legacy') {
            return getPropertyDescriptor(target, name);
        }
    };
}
export function determineCompiler(descriptor) {
    if (typeof descriptor === 'object') {
        // The class has been compiled by Babel using @babel/plugin-proposal-decorators in legacy mode
        return 'babel-legacy';
    }
    else {
        // The class has been compiled by the TypeScript compiler
        return 'typescript';
    }
}
//# sourceMappingURL=decorators.js.map