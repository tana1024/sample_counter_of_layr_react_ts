import { hasOwnProperty } from 'core-helpers';
import { Attribute } from './attribute';
import { isComponentInstance } from '../utilities';
/**
 * *Inherits from [`Attribute`](https://layrjs.com/docs/v1/reference/attribute).*
 *
 * A base class from which [`PrimaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/primary-identifier-attribute) and [`SecondaryIdentifierAttribute`](https://layrjs.com/docs/v1/reference/secondary-identifier-attribute) are constructed. Unless you build a custom identifier attribute class, you probably won't have to use this class directly.
 */
export class IdentifierAttribute extends Attribute {
    constructor(name, parent, options = {}) {
        if (!isComponentInstance(parent)) {
            throw new Error(`Cannot create a primary identifier attribute with a parent that is not a component instance (property: '${name}')`);
        }
        super(name, parent, options);
    }
    getParent() {
        return super.getParent();
    }
    // === Options ===
    setOptions(options = {}) {
        const { valueType = 'string' } = options;
        if (valueType.endsWith('?')) {
            throw new Error(`The value of an identifier attribute cannot be optional (${this.describe()}, specified type: '${valueType}')`);
        }
        if (valueType !== 'string' && valueType !== 'number') {
            throw new Error(`The type of an identifier attribute must be 'string' or 'number' (${this.describe()}, specified type: '${valueType}')`);
        }
        super.setOptions({ ...options, valueType });
    }
    // === Value ===
    getValue(options = {}) {
        return super.getValue(options);
    }
    setValue(value, { source = 0 } = {}) {
        if (hasOwnProperty(this, '_ignoreNextSetValueCall')) {
            delete this._ignoreNextSetValueCall;
            return { previousValue: undefined, newValue: undefined };
        }
        const { previousValue, newValue } = super.setValue(value, { source });
        const parent = this.getParent();
        const identityMap = parent.constructor.getIdentityMap();
        identityMap.updateComponent(parent, this.getName(), { previousValue, newValue });
        return { previousValue, newValue };
    }
    unsetValue() {
        if (!this.isSet()) {
            return { previousValue: undefined };
        }
        const { previousValue } = super.unsetValue();
        const parent = this.getParent();
        const identityMap = parent.constructor.getIdentityMap();
        identityMap.updateComponent(parent, this.getName(), { previousValue, newValue: undefined });
        return { previousValue };
    }
    // === Utilities ===
    static isIdentifierAttribute(value) {
        return isIdentifierAttributeInstance(value);
    }
}
/**
 * Returns whether the specified value is an `IdentifierAttribute` class.
 *
 * @param value A value of any type.
 *
 * @returns A boolean.
 *
 * @category Utilities
 */
export function isIdentifierAttributeClass(value) {
    return typeof (value === null || value === void 0 ? void 0 : value.isIdentifierAttribute) === 'function';
}
/**
 * Returns whether the specified value is an `IdentifierAttribute` instance.
 *
 * @param value A value of any type.
 *
 * @returns A boolean.
 *
 * @category Utilities
 */
export function isIdentifierAttributeInstance(value) {
    return isIdentifierAttributeClass(value === null || value === void 0 ? void 0 : value.constructor) === true;
}
//# sourceMappingURL=identifier-attribute.js.map