import { possiblyAsync } from 'possibly-async';
import isEmpty from 'lodash/isEmpty';
import { ValueType } from './value-type';
import { mergeAttributeSelectors, intersectAttributeSelectors } from '../attribute-selector';
import { joinAttributePath } from '../../utilities';
export class ArrayValueType extends ValueType {
    constructor(itemType, attribute, options = {}) {
        super(attribute, options);
        this._itemType = itemType;
    }
    getItemType() {
        return this._itemType;
    }
    toString() {
        return `${this.getItemType().toString()}[]${super.toString()}`;
    }
    checkValue(values, attribute) {
        super.checkValue(values, attribute);
        if (values === undefined) {
            // `values` is undefined and isOptional() is true
            return;
        }
        const itemType = this.getItemType();
        for (const value of values) {
            itemType.checkValue(value, attribute);
        }
    }
    _checkValue(values, attribute) {
        var _a;
        return (_a = super._checkValue(values, attribute)) !== null && _a !== void 0 ? _a : Array.isArray(values);
    }
    _traverseAttributes(iteratee, attribute, items, options) {
        const { setAttributesOnly } = options;
        const itemType = this.getItemType();
        if (!setAttributesOnly) {
            itemType._traverseAttributes(iteratee, attribute, undefined, options);
            return;
        }
        if (Array.isArray(items)) {
            for (const item of items) {
                itemType._traverseAttributes(iteratee, attribute, item, options);
            }
        }
    }
    _resolveAttributeSelector(normalizedAttributeSelector, attribute, items, options) {
        const { setAttributesOnly, aggregationMode } = options;
        options = { ...options, _skipUnchangedAttributes: false, _isArrayItem: true };
        if (normalizedAttributeSelector === false) {
            return false;
        }
        const itemType = this.getItemType();
        if (!setAttributesOnly || !Array.isArray(items) || items.length === 0) {
            return itemType._resolveAttributeSelector(normalizedAttributeSelector, attribute, undefined, options);
        }
        let resolvedAttributeSelector = undefined;
        const aggregate = aggregationMode === 'union' ? mergeAttributeSelectors : intersectAttributeSelectors;
        for (const item of items) {
            const itemAttributeSelector = itemType._resolveAttributeSelector(normalizedAttributeSelector, attribute, item, options);
            if (resolvedAttributeSelector === undefined) {
                resolvedAttributeSelector = itemAttributeSelector;
            }
            else {
                resolvedAttributeSelector = aggregate(resolvedAttributeSelector, itemAttributeSelector);
            }
        }
        return resolvedAttributeSelector;
    }
    runValidators(values, attributeSelector) {
        const failedValidators = super.runValidators(values, attributeSelector);
        if (values !== undefined) {
            const itemType = this.getItemType();
            values.forEach((value, index) => {
                const failedItemValidators = itemType.runValidators(value, attributeSelector);
                for (const { validator, path } of failedItemValidators) {
                    failedValidators.push({ validator, path: joinAttributePath([`[${index}]`, path]) });
                }
            });
        }
        return failedValidators;
    }
    serializeValue(items, attribute, options = {}) {
        if (Array.isArray(items)) {
            const itemType = this.getItemType();
            return possiblyAsync.map(items, (item) => itemType.serializeValue(item, attribute, options));
        }
        return super.serializeValue(items, attribute, options);
    }
    introspect() {
        const introspectedArrayType = super.introspect();
        const introspectedItemType = this.getItemType().introspect();
        delete introspectedItemType.valueType;
        if (!isEmpty(introspectedItemType)) {
            introspectedArrayType.items = introspectedItemType;
        }
        return introspectedArrayType;
    }
    static isArrayValueType(value) {
        return isArrayValueTypeInstance(value);
    }
}
export function isArrayValueTypeInstance(value) {
    var _a;
    return typeof ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.isArrayValueType) === 'function';
}
//# sourceMappingURL=array-value-type.js.map