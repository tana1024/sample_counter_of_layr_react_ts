import { ValueType } from './value-type';
import { isComponentClassOrInstance, isComponentClass, isComponentInstance, ensureComponentClass, assertIsComponentType } from '../../utilities';
export class ComponentValueType extends ValueType {
    constructor(componentType, attribute, options = {}) {
        super(attribute, options);
        assertIsComponentType(componentType);
        this._componentType = componentType;
    }
    getComponentType() {
        return this._componentType;
    }
    getComponent(attribute) {
        return ensureComponentClass(attribute.getParent()).getComponentOfType(this.getComponentType());
    }
    toString() {
        return `${this.getComponentType()}${super.toString()}`;
    }
    _checkValue(value, attribute) {
        const result = super._checkValue(value, attribute);
        if (result !== undefined) {
            return result;
        }
        const component = this.getComponent(attribute);
        if (value === component) {
            return true;
        }
        if (isComponentClass(value) && isComponentClass(component)) {
            return value.isForkOf(component);
        }
        if (isComponentInstance(value) && isComponentInstance(component)) {
            return value.constructor === component.constructor || value.isForkOf(component);
        }
        return false;
    }
    _traverseAttributes(iteratee, attribute, component, options) {
        const { setAttributesOnly } = options;
        if (!setAttributesOnly) {
            component = this.getComponent(attribute);
        }
        if (isComponentClassOrInstance(component)) {
            component.__traverseAttributes(iteratee, options);
        }
    }
    _resolveAttributeSelector(normalizedAttributeSelector, attribute, component, options) {
        const { setAttributesOnly } = options;
        if (normalizedAttributeSelector === false) {
            return false;
        }
        if (!setAttributesOnly) {
            component = this.getComponent(attribute);
        }
        if (!isComponentClassOrInstance(component)) {
            return {}; // `setAttributesOnly` is true and `component` is undefined
        }
        return component.__resolveAttributeSelector(normalizedAttributeSelector, options);
    }
    runValidators(value, attributeSelector) {
        const failedValidators = super.runValidators(value, attributeSelector);
        if (isComponentClassOrInstance(value)) {
            const componentFailedValidators = value.runValidators(attributeSelector);
            failedValidators.push(...componentFailedValidators);
        }
        return failedValidators;
    }
    serializeValue(value, attribute, options = {}) {
        if (isComponentClassOrInstance(value)) {
            return value.__serialize(options);
        }
        return super.serializeValue(value, attribute, options);
    }
    static isComponentValueType(value) {
        return isComponentValueTypeInstance(value);
    }
}
export function isComponentValueTypeInstance(value) {
    var _a;
    return typeof ((_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.isComponentValueType) === 'function';
}
//# sourceMappingURL=component-value-type.js.map