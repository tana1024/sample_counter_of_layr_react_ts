"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEmbeddable = exports.canBeObserved = exports.isObservable = exports.ObserverSet = exports.createObservable = exports.Observable = void 0;
const core_helpers_1 = require("core-helpers");
/**
 * Brings observability to any class.
 *
 * This mixin is used to construct several Layr's classes such as [`Component`](https://layrjs.com/docs/v1/reference/component) or [`Attribute`](https://layrjs.com/docs/v1/reference/attribute). So, in most cases, you'll have the capabilities provided by this mixin without having to call it.
 *
 * #### Usage
 *
 * Call the `Observable()` mixin with any class to construct an [`Observable`](https://layrjs.com/docs/v1/reference/observable#observable-class) class. Then, you can add some observers by using the [`addObserver()`](https://layrjs.com/docs/v1/reference/observable#add-observer-dual-method) method, and trigger their execution anytime by using the [`callObservers()`](https://layrjs.com/docs/v1/reference/observable#call-observers-dual-method) method.
 *
 * For example, let's define a `Movie` class using the `Observable()` mixin:
 *
 * ```
 * // JS
 *
 * import {Observable} from '@layr/observable';
 *
 * class Movie extends Observable(Object) {
 *   get title() {
 *     return this._title;
 *   }
 *
 *   set title(title) {
 *     this._title = title;
 *     this.callObservers();
 *   }
 * }
 * ```
 *
 * ```
 * // TS
 *
 * import {Observable} from '@layr/observable';
 *
 * class Movie extends Observable(Object) {
 *   _title?: string;
 *
 *   get title() {
 *     return this._title;
 *   }
 *
 *   set title(title: string) {
 *     this._title = title;
 *     this.callObservers();
 *   }
 * }
 * ```
 *
 * Next, we can create a `Movie` instance, and observe it:
 *
 * ```
 * const movie = new Movie();
 *
 * movie.addObserver(() => {
 *   console.log('The movie's title has changed');
 * })
 * ```
 *
 * And now, every time we change the title of `movie`, its observer will be automatically executed:
 *
 * ```
 * movie.title = 'Inception';
 *
 * // Should display:
 * // 'The movie's title has changed'
 * ```
 *
 * > Note that the same result could have been achieved by using a Layr [`Component`](https://layrjs.com/docs/v1/reference/component):
 * >
 * > ```
 * > // JS
 * >
 * > import {Component, attribute} from '@layr/component';
 * >
 * > class Movie extends Component {
 * >   @attribute('string?') title;
 * > }
 * > ```
 * >
 * > ```
 * > // TS
 * >
 * > import {Component, attribute} from '@layr/component';
 * >
 * > class Movie extends Component {
 * >   @attribute('string?') title?: string;
 * > }
 * > ```
 *
 * ### Observable <badge type="primary">class</badge> {#observable-class}
 *
 * An `Observable` class is constructed by calling the `Observable()` mixin ([see above](https://layrjs.com/docs/v1/reference/observable#observable-mixin)).
 * @mixin
 */
function Observable(Base) {
    if (!core_helpers_1.isClass(Base)) {
        throw new Error(`The Observable mixin should be applied on a class (received type: '${core_helpers_1.getTypeOf(Base)}')`);
    }
    if (typeof Base.isObservable === 'function') {
        return Base;
    }
    const Observable = class extends Base {
        /**
         * Adds an observer to the current class or instance.
         *
         * @param observer A function that will be automatically executed when the [`callObservers()`](https://layrjs.com/docs/v1/reference/observable#call-observers-dual-method) method is called. Alternatively, you can specify an observable for which the observers should be executed, and doing so, you can connect an observable to another observable.
         *
         * @example
         * ```
         * Movie.addObserver(() => {
         *   // A `Movie` class observer
         * });
         *
         * const movie = new Movie();
         *
         * movie.addObserver(() => {
         *   // A `Movie` instance observer
         * });
         *
         * const actor = new Actor();
         *
         * // Connect `actor` to `movie` so that when `callObservers()` is called on `actor`,
         * // then `callObservers()` is automatically called on `movie`
         * actor.addObserver(movie);
         * ```
         *
         * @category Methods
         */
        static get addObserver() {
            return this.prototype.addObserver;
        }
        /**
         * Adds an observer to the current class or instance.
         *
         * @param observer A function that will be automatically executed when the [`callObservers()`](https://layrjs.com/docs/v1/reference/observable#call-observers-dual-method) method is called. Alternatively, you can specify an observable for which the observers should be executed, and doing so, you can connect an observable to another observable.
         *
         * @example
         * ```
         * Movie.addObserver(() => {
         *   // A `Movie` class observer
         * });
         *
         * const movie = new Movie();
         *
         * movie.addObserver(() => {
         *   // A `Movie` instance observer
         * });
         *
         * const actor = new Actor();
         *
         * // Connect `actor` to `movie` so that when `callObservers()` is called on `actor`,
         * // then `callObservers()` is automatically called on `movie`
         * actor.addObserver(movie);
         * ```
         *
         * @category Methods
         */
        addObserver(observer) {
            this.__getObservers().add(observer);
        }
        /**
         * Removes an observer from the current class or instance.
         *
         * @param observer A function or a connected observable.
         *
         * @example
         * ```
         * const observer = () => {
         *   // ...
         * }
         *
         * // Add `observer` to the `Movie` class
         * Movie.addObserver(observer);
         *
         * // Remove `observer` from to the `Movie` class
         * Movie.removeObserver(observer);
         *
         * const movie = new Movie();
         * const actor = new Actor();
         *
         * // Connect `actor` to `movie`
         * actor.addObserver(movie);
         *
         * // Remove the connection between `actor` and `movie`
         * actor.removeObserver(movie);
         * ```
         *
         * @category Methods
         */
        static get removeObserver() {
            return this.prototype.removeObserver;
        }
        /**
         * Removes an observer from the current class or instance.
         *
         * @param observer A function or a connected observable.
         *
         * @example
         * ```
         * const observer = () => {
         *   // ...
         * }
         *
         * // Add `observer` to the `Movie` class
         * Movie.addObserver(observer);
         *
         * // Remove `observer` from to the `Movie` class
         * Movie.removeObserver(observer);
         *
         * const movie = new Movie();
         * const actor = new Actor();
         *
         * // Connect `actor` to `movie`
         * actor.addObserver(movie);
         *
         * // Remove the connection between `actor` and `movie`
         * actor.removeObserver(movie);
         * ```
         *
         * @category Methods
         */
        removeObserver(observer) {
            this.__getObservers().remove(observer);
        }
        /**
         * Calls the observers of the current class or instance.
         *
         * @param [payload] An optional object to pass to the observers when they are executed.
         *
         * @example
         * ```
         * const movie = new Movie();
         *
         * movie.addObserver((payload) => {
         *   console.log('Observer called with:', payload);
         * });
         *
         * movie.callObservers();
         *
         * // Should display:
         * // 'Observer called with: undefined'
         *
         * movie.callObservers({changes: ['title']});
         *
         * // Should display:
         * // 'Observer called with: {changes: ['title']}'
         * ```
         *
         * @category Methods
         */
        static get callObservers() {
            return this.prototype.callObservers;
        }
        /**
         * Calls the observers of the current class or instance.
         *
         * @param [payload] An optional object to pass to the observers when they are executed.
         *
         * @example
         * ```
         * const movie = new Movie();
         *
         * movie.addObserver((payload) => {
         *   console.log('Observer called with:', payload);
         * });
         *
         * movie.callObservers();
         *
         * // Should display:
         * // 'Observer called with: undefined'
         *
         * movie.callObservers({changes: ['title']});
         *
         * // Should display:
         * // 'Observer called with: {changes: ['title']}'
         * ```
         *
         * @category Methods
         */
        callObservers(payload) {
            this.__getObservers().call(payload);
        }
        static get __getObservers() {
            return this.prototype.__getObservers;
        }
        __getObservers() {
            if (!core_helpers_1.hasOwnProperty(this, '__observers')) {
                Object.defineProperty(this, '__observers', { value: new ObserverSet() });
            }
            return this.__observers;
        }
        static get isObservable() {
            return this.prototype.isObservable;
        }
        isObservable(value) {
            return isObservable(value);
        }
    };
    return Observable;
}
exports.Observable = Observable;
/**
 * Returns an observable from an existing object or array.
 *
 * The returned observable is observed deeply. So, for example, if an object contains a nested object, modifying the nested object will trigger the execution of the parent's observers.
 *
 * The returned observable provides the same methods as an [`Observable`](https://layrjs.com/docs/v1/reference/observable#observable-class) instance:
 *
 * - [`addObserver()`](https://layrjs.com/docs/v1/reference/observable#add-observer-dual-method)
 * - [`removeObserver()`](https://layrjs.com/docs/v1/reference/observable#remove-observer-dual-method)
 * - [`callObservers()`](https://layrjs.com/docs/v1/reference/observable#call-observers-dual-method)
 *
 * @param target A JavaScript plain object or array that you want to observe.
 *
 * @returns An observable objet or array.
 *
 * @example
 * ```
 * import {createObservable} from '@layr/observable';
 *
 * // Create an observable `movie`
 * const movie = createObservable({
 *   title: 'Inception',
 *   genres: ['drama'],
 *   details: {duration: 120}
 * });
 *
 * // Add an observer
 * movie.addObserver(() => {
 *   // ...
 * });
 *
 * // Then, any of the following changes on `movie` will call the observer:
 * movie.title = 'Inception 2';
 * delete movie.title;
 * movie.year = 2010;
 * movie.genres.push('action');
 * movie.genres[1] = 'sci-fi';
 * movie.details.duration = 125;
 * ```
 *
 * @category Bringing Observability to an Object or an Array
 */
function createObservable(target) {
    if (!canBeObserved(target)) {
        throw new Error(`Cannot create an observable from a target that is not an object, an array, or a function`);
    }
    if (isObservable(target)) {
        return target;
    }
    const observers = new ObserverSet();
    const handleAddObserver = function (observer) {
        observers.add(observer);
    };
    const handleRemoveObserver = function (observer) {
        observers.remove(observer);
    };
    const handleCallObservers = function (payload) {
        observers.call(payload);
    };
    const handleIsObservable = function (value) {
        return isObservable(value);
    };
    let observable;
    const handler = {
        has(target, key) {
            if (key === 'addObserver' ||
                key === 'removeObserver' ||
                key === 'callObservers' ||
                key === 'isObservable') {
                return true;
            }
            return Reflect.has(target, key);
        },
        get(target, key, receiver) {
            if (receiver === observable) {
                if (key === 'addObserver') {
                    return handleAddObserver;
                }
                if (key === 'removeObserver') {
                    return handleRemoveObserver;
                }
                if (key === 'callObservers') {
                    return handleCallObservers;
                }
                if (key === 'isObservable') {
                    return handleIsObservable;
                }
            }
            return Reflect.get(target, key, receiver);
        },
        set(target, key, newValue, receiver) {
            if (key === 'addObserver' ||
                key === 'removeObserver' ||
                key === 'callObservers' ||
                key === 'isObservable') {
                throw new Error(`Cannot set a property named 'addObserver', 'removeObserver', 'callObservers' or 'isObservable' in an observed object`);
            }
            if (canBeObserved(newValue) && !isObservable(newValue) && isEmbeddable(newValue)) {
                newValue = createObservable(newValue);
            }
            const previousValue = Reflect.get(target, key, receiver);
            const result = Reflect.set(target, key, newValue, receiver);
            if (receiver === observable && (newValue === null || newValue === void 0 ? void 0 : newValue.valueOf()) !== (previousValue === null || previousValue === void 0 ? void 0 : previousValue.valueOf())) {
                if (isObservable(previousValue) && isEmbeddable(previousValue)) {
                    previousValue.removeObserver(handleCallObservers);
                }
                if (isObservable(newValue) && isEmbeddable(newValue)) {
                    newValue.addObserver(handleCallObservers);
                }
                handleCallObservers();
            }
            return result;
        },
        deleteProperty(target, key) {
            if (key === 'addObserver' ||
                key === 'removeObserver' ||
                key === 'callObservers' ||
                key === 'isObservable') {
                throw new Error(`Cannot delete a property named 'addObserver', 'removeObserver', 'callObservers' or 'isObservable' in an observed object`);
            }
            const previousValue = Reflect.get(target, key);
            if (isObservable(previousValue) && isEmbeddable(previousValue)) {
                previousValue.removeObserver(handleCallObservers);
            }
            const result = Reflect.deleteProperty(target, key);
            handleCallObservers();
            return result;
        }
    };
    observable = new Proxy(target, handler);
    const observeExistingValue = function (key, value) {
        if (canBeObserved(value) && !isObservable(value) && isEmbeddable(value)) {
            value = createObservable(value);
            target[key] = value;
        }
        if (isObservable(value)) {
            value.addObserver(observable);
        }
    };
    if (Array.isArray(target)) {
        for (let index = 0; index < target.length; index++) {
            observeExistingValue(index, target[index]);
        }
    }
    else if (core_helpers_1.isPlainObject(target)) {
        for (const [key, value] of Object.entries(target)) {
            observeExistingValue(key, value);
        }
    }
    return observable;
}
exports.createObservable = createObservable;
class ObserverSet {
    constructor() {
        this._observers = [];
    }
    add(observer) {
        if (!(typeof observer === 'function' || isObservable(observer))) {
            throw new Error(`Cannot add an observer that is not a function or an observable`);
        }
        this._observers.push(observer);
    }
    remove(observer) {
        if (!(typeof observer === 'function' || isObservable(observer))) {
            throw new Error(`Cannot remove an observer that is not a function or an observable`);
        }
        const index = this._observers.indexOf(observer);
        if (index !== -1) {
            this._observers.splice(index, 1);
        }
    }
    call({ _observerStack = new Set(), ...payload } = {}) {
        for (const observer of this._observers) {
            if (_observerStack.has(observer)) {
                continue; // Avoid looping indefinitely when a circular reference is encountered
            }
            _observerStack.add(observer);
            try {
                if (isObservable(observer)) {
                    observer.callObservers({ _observerStack, ...payload });
                }
                else {
                    observer({ _observerStack, ...payload });
                }
            }
            finally {
                _observerStack.delete(observer);
            }
        }
    }
}
exports.ObserverSet = ObserverSet;
/**
 * Returns whether the specified value is observable. When a value is observable, you can use any the following methods on it: [`addObserver()`](https://layrjs.com/docs/v1/reference/observable#add-observer-dual-method), [`removeObserver()`](https://layrjs.com/docs/v1/reference/observable#remove-observer-dual-method), and [`callObservers()`](https://layrjs.com/docs/v1/reference/observable#call-observers-dual-method).
 *
 * @param value A value of any type.
 *
 * @returns A boolean.
 *
 * @category Utilities
 */
function isObservable(value) {
    return typeof (value === null || value === void 0 ? void 0 : value.isObservable) === 'function';
}
exports.isObservable = isObservable;
function canBeObserved(value) {
    return ((typeof value === 'object' && value !== null && !(value instanceof Date)) ||
        typeof value === 'function');
}
exports.canBeObserved = canBeObserved;
function isEmbeddable(value) {
    var _a;
    const isEmbedded = (_a = value === null || value === void 0 ? void 0 : value.constructor) === null || _a === void 0 ? void 0 : _a.isEmbedded;
    if (typeof isEmbedded === 'function' && isEmbedded() === false) {
        return false;
    }
    return true;
}
exports.isEmbeddable = isEmbeddable;
//# sourceMappingURL=observable.js.map