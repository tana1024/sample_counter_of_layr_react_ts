import { isComponentClassOrInstance, assertIsComponentClass, serialize, deserialize } from '@layr/component';
import { invokeQuery } from '@deepr/runtime';
import { possiblyAsync } from 'possibly-async';
import debugModule from 'debug';
// To display the debug log, set this environment:
// DEBUG=layr:component-server DEBUG_DEPTH=5
const debug = debugModule('layr:component-server');
// To display errors occurring while invoking queries, set this environment:
// DEBUG=layr:component-server:error DEBUG_DEPTH=5
const debugError = debugModule('layr:component-server:error');
import { isComponentServerInstance } from './utilities';
/**
 * A base class allowing to serve a root [`Component`](https://layrjs.com/docs/v1/reference/component) so it can be accessed by a [`ComponentClient`](https://layrjs.com/docs/v1/reference/component-client).
 *
 * Typically, instead of using this class, you would use a class such as [`ComponentHTTPServer`](https://layrjs.com/docs/v1/reference/component-http-server), or a middleware such as [`component-express-middleware`](https://layrjs.com/docs/v1/reference/component-express-middleware).
 */
export class ComponentServer {
    /**
     * Creates a component server.
     *
     * @param component The root [`Component`](https://layrjs.com/docs/v1/reference/component) class to serve.
     * @param [options.version] A number specifying the version of the returned component server (default: `undefined`).
     *
     * @returns A `ComponentServer` instance.
     *
     * @examplelink See [`ComponentClient`'s example](https://layrjs.com/docs/v1/reference/component-client#constructor).
     *
     * @category Creation
     */
    constructor(component, options = {}) {
        const { name, version } = options;
        assertIsComponentClass(component);
        const introspectedComponent = component.introspect();
        if (introspectedComponent === undefined) {
            throw new Error(`Cannot serve a component that has no exposed properties or doesn't provide any exposed components (${component.describeComponent()})`);
        }
        this._component = component;
        this._introspectedComponent = introspectedComponent;
        this._name = name;
        this._version = version;
    }
    receive(request) {
        const { query: serializedQuery, components: serializedComponents, version: clientVersion } = request;
        this.validateVersion(clientVersion);
        const forkedComponent = this._component.fork();
        const deeprRoot = this.getDeeprRoot();
        const componentGetter = (type) => forkedComponent.getComponentOfType(type);
        const getFilter = function (attribute) {
            return attribute.operationIsAllowed('get');
        };
        const setFilter = function (attribute) {
            return attribute.operationIsAllowed('set');
        };
        const authorizer = function (name, operation, _params) {
            if (this === deeprRoot && name === 'introspect' && operation === 'call') {
                return true;
            }
            if (isComponentClassOrInstance(this)) {
                const property = this.hasProperty(name) ? this.getProperty(name) : undefined;
                if (property !== undefined) {
                    return property.operationIsAllowed(operation);
                }
            }
            return false;
        };
        const errorHandler = function (error) {
            debugError(`An error occurred while invoking a query (query: %o, components: %o)\n%s`, serializedQuery, serializedComponents, error.stack);
            return error;
        };
        debugRequest({ serializedQuery, serializedComponents });
        return possiblyAsync(this._deserializeRequest({ serializedQuery, serializedComponents }, { componentGetter, attributeFilter: setFilter }), ({ deserializedQuery, deserializedComponents }) => possiblyAsync(invokeQuery(deeprRoot, deserializedQuery, { authorizer, errorHandler }), (result) => possiblyAsync(this._serializeResponse({ result, components: deserializedComponents }, { attributeFilter: getFilter }), ({ serializedResult, serializedComponents }) => {
            debugResponse({ serializedResult, serializedComponents });
            return {
                ...(serializedResult !== undefined && { result: serializedResult }),
                ...(serializedComponents !== undefined && { components: serializedComponents })
            };
        })));
    }
    _deserializeRequest({ serializedQuery, serializedComponents }, { componentGetter, attributeFilter }) {
        return possiblyAsync(deserialize(serializedComponents, {
            componentGetter,
            attributeFilter,
            source: -1
        }), (deserializedComponents) => {
            const deserializedComponentSet = new Set(deserializedComponents);
            return possiblyAsync(deserialize(serializedQuery, {
                componentGetter,
                attributeFilter,
                deserializedComponents: deserializedComponentSet,
                source: -1
            }), (deserializedQuery) => {
                deserializedComponents = Array.from(deserializedComponentSet);
                return { deserializedQuery, deserializedComponents };
            });
        });
    }
    _serializeResponse({ result, components }, { attributeFilter }) {
        const serializedComponents = new Set();
        const componentDependencies = new Set(components);
        const possiblyAsyncSerializedResult = result !== undefined
            ? serialize(result, {
                attributeFilter,
                serializedComponents,
                componentDependencies,
                serializeFunctions: true,
                target: -1
            })
            : undefined;
        return possiblyAsync(possiblyAsyncSerializedResult, (serializedResult) => {
            let serializedComponentDependencies;
            const handledComponentDependencies = new Set(serializedComponents);
            const serializeComponentDependencies = function (componentDependencies) {
                if (componentDependencies.size === 0) {
                    return;
                }
                const additionalComponentDependencies = new Set();
                return possiblyAsync(possiblyAsync.forEach(componentDependencies.values(), (componentDependency) => {
                    if (handledComponentDependencies.has(componentDependency)) {
                        return;
                    }
                    return possiblyAsync(componentDependency.serialize({
                        attributeFilter,
                        componentDependencies: additionalComponentDependencies,
                        ignoreEmptyComponents: true,
                        serializeFunctions: true,
                        target: -1
                    }), (serializedComponentDependency) => {
                        if (serializedComponentDependency !== undefined) {
                            if (serializedComponentDependencies === undefined) {
                                serializedComponentDependencies = [];
                            }
                            serializedComponentDependencies.push(serializedComponentDependency);
                        }
                        handledComponentDependencies.add(componentDependency);
                    });
                }), () => serializeComponentDependencies(additionalComponentDependencies));
            };
            return possiblyAsync(serializeComponentDependencies(componentDependencies), () => ({
                serializedResult,
                serializedComponents: serializedComponentDependencies
            }));
        });
    }
    validateVersion(clientVersion) {
        const serverVersion = this._version;
        if (clientVersion !== serverVersion) {
            throw Object.assign(new Error(`The component client version (${clientVersion}) doesn't match the component server version (${serverVersion})`), { code: 'COMPONENT_CLIENT_VERSION_DOES_NOT_MATCH_COMPONENT_SERVER_VERSION', expose: true });
        }
    }
    getDeeprRoot() {
        if (this._deeprRoot === undefined) {
            this._deeprRoot = Object.create(null);
            this._deeprRoot.introspect = () => ({
                ...(this._name !== undefined && { name: this._name }),
                component: this._introspectedComponent
            });
        }
        return this._deeprRoot;
    }
    static isComponentServer(value) {
        return isComponentServerInstance(value);
    }
}
export function ensureComponentServer(componentOrComponentServer, options = {}) {
    if (isComponentServerInstance(componentOrComponentServer)) {
        return componentOrComponentServer;
    }
    return new ComponentServer(componentOrComponentServer, options);
}
function debugRequest({ serializedQuery, serializedComponents }) {
    let message = 'Receiving query: %o';
    const values = [serializedQuery];
    if (serializedComponents !== undefined) {
        message += ' (components: %o)';
        values.push(serializedComponents);
    }
    debug(message, ...values);
}
function debugResponse({ serializedResult, serializedComponents }) {
    let message = 'Returning result: %o';
    const values = [serializedResult];
    if (serializedComponents !== undefined) {
        message += ' (components: %o)';
        values.push(serializedComponents);
    }
    debug(message, ...values);
}
//# sourceMappingURL=component-server.js.map