"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fork = void 0;
const tslib_1 = require("tslib");
const simple_cloning_1 = require("simple-cloning");
const isObjectLike_1 = tslib_1.__importDefault(require("lodash/isObjectLike"));
function fork(value, options) {
    if (Array.isArray(value)) {
        return forkArray(value, options);
    }
    if (isObjectLike_1.default(value)) {
        return forkObject(value, options);
    }
    if (typeof value === 'function') {
        throw new Error('Cannot fork a function');
    }
    return value;
}
exports.fork = fork;
function forkObject(object, options) {
    const objectForker = options === null || options === void 0 ? void 0 : options.objectForker;
    if (objectForker !== undefined) {
        const forkedObject = objectForker(object);
        if (forkedObject !== undefined) {
            return forkedObject;
        }
    }
    if (simple_cloning_1.isLeaf(object)) {
        return simple_cloning_1.clone(object);
    }
    return forkAttributes(object, options);
}
function forkArray(array, options) {
    // OPTIMIZE: Consider using a proxy to lazily fork the items
    return array.map((item) => fork(item, options));
}
function forkAttributes(object, options) {
    const forkedObject = Object.create(object);
    // OPTIMIZE: Consider using a proxy to lazily fork the attributes
    for (const [name, value] of Object.entries(object)) {
        forkedObject[name] = fork(value, options);
    }
    return forkedObject;
}
//# sourceMappingURL=forking.js.map