import { possiblyAsync } from 'possibly-async';
export function invokeExpression(target, expression, options = {}) {
    if (target === undefined) {
        throw new Error(`'target' parameter is missing`);
    }
    if (expression === undefined) {
        throw new Error(`'expression' parameter is missing`);
    }
    return _invokeExpression(target, expression, options);
}
function _invokeExpression(target, expression, options, _isMapping = false) {
    if (Array.isArray(expression)) {
        const results = possiblyAsync.map(expression, (expression) => _invokeExpression(target, expression, options, true));
        return results;
    }
    const { errorHandler } = options;
    return possiblyAsync.invoke(function () {
        return __invokeExpression(target, expression, options);
    }, function (result) {
        return result;
    }, function (error) {
        if (errorHandler === undefined) {
            throw error;
        }
        const result = errorHandler.call(target, error);
        return _isMapping ? { [possiblyAsync.breakSymbol]: result } : result;
    });
}
function __invokeExpression(target, { sourceKey, isOptional, params, sourceValue, useCollectionElements, nestedExpressions, nextExpression }, options) {
    target = sourceKey ? evaluateKey(target, sourceKey, { params, isOptional }, options) : target;
    return possiblyAsync(target, function (target) {
        if (sourceValue !== undefined) {
            target = sourceValue;
        }
        if (!(nestedExpressions || nextExpression)) {
            return target;
        }
        if (target === undefined) {
            if (isOptional) {
                return undefined;
            }
            throw new Error(`Cannot execute a query on \`undefined\` (key: '${sourceKey}')`);
        }
        if (useCollectionElements !== undefined) {
            let collection = target;
            if (typeof useCollectionElements === 'number') {
                let index = useCollectionElements;
                if (index < 0) {
                    index = collection.length + index;
                }
                target = collection[index];
                if (target === undefined) {
                    if (isOptional) {
                        return undefined;
                    }
                    throw new Error(`Cannot execute a query on a missing collection item (key: '${sourceKey}', index: ${index})`);
                }
            }
            else {
                const indexes = useCollectionElements;
                if (indexes.length > 0) {
                    collection = collection.slice(...indexes);
                }
                const results = possiblyAsync.map(collection, function (item) {
                    return _invokeExpression(item, { sourceKey: '', nestedExpressions, nextExpression }, options, true);
                });
                return results;
            }
        }
        if (nextExpression) {
            return _invokeExpression(target, nextExpression, options);
        }
        const results = possiblyAsync.mapValues(nestedExpressions, function (nestedExpression) {
            return _invokeExpression(target, nestedExpression, options, true);
        });
        return results;
    });
}
function evaluateKey(target, key, { params, isOptional }, options) {
    const value = target[key];
    if (params === undefined) {
        return evaluateAttribute(target, key, value, options);
    }
    return evaluateMethod(target, key, value, { params, isOptional }, options);
}
function evaluateAttribute(target, key, value, { authorizer }) {
    return possiblyAsync(evaluateAuthorizer(target, authorizer, key, 'get'), function (isAllowed) {
        if (!isAllowed) {
            throw new Error(`Cannot get the value of an attribute that is not allowed (name: '${key}')`);
        }
        return value;
    });
}
function evaluateMethod(target, key, method, { params, isOptional }, { context, authorizer }) {
    if (method === undefined) {
        if (isOptional) {
            return undefined;
        }
        throw new Error(`Couldn't find a method matching the key '${key}'`);
    }
    return possiblyAsync(evaluateAuthorizer(target, authorizer, key, 'call', params), function (isAllowed) {
        if (!isAllowed) {
            throw new Error(`Cannot execute a method that is not allowed (name: '${key}')`);
        }
        return method.call(target, ...params, context);
    });
}
function evaluateAuthorizer(target, authorizer, key, operation, params) {
    if (authorizer === undefined) {
        return true;
    }
    return authorizer.call(target, key, operation, params);
}
//# sourceMappingURL=runtime.js.map