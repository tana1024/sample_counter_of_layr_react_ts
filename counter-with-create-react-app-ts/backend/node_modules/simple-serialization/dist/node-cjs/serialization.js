"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeError = exports.serializeRegExp = exports.serializeDate = exports.serializeUndefined = exports.serialize = void 0;
const possibly_async_1 = require("possibly-async");
function serialize(value, options) {
    if (value === undefined) {
        return serializeUndefined();
    }
    if (value === null) {
        return null;
    }
    if (Array.isArray(value)) {
        return serializeArray(value, options);
    }
    if (typeof value === 'object' || typeof value === 'function') {
        return serializeObjectOrFunction(value, options);
    }
    if (Number.isNaN(value)) {
        throw new Error('Cannot serialize a NaN value');
    }
    return value;
}
exports.serialize = serialize;
function serializeUndefined() {
    return { __undefined: true };
}
exports.serializeUndefined = serializeUndefined;
function serializeObjectOrFunction(object, options) {
    const objectSerializer = options === null || options === void 0 ? void 0 : options.objectSerializer;
    if (objectSerializer !== undefined) {
        const serializedObject = objectSerializer(object);
        if (serializedObject !== undefined) {
            return serializedObject;
        }
    }
    const functionSerializer = options === null || options === void 0 ? void 0 : options.functionSerializer;
    if (typeof object === 'function' && functionSerializer !== undefined) {
        const serializedFunction = functionSerializer(object);
        if (serializedFunction !== undefined) {
            return serializedFunction;
        }
    }
    if (object instanceof Date) {
        return serializeDate(object);
    }
    if (object instanceof RegExp) {
        return serializeRegExp(object);
    }
    if (object instanceof Error) {
        return serializeError(object, options);
    }
    if (typeof object.toJSON === 'function') {
        return serialize(object.toJSON(), options);
    }
    return serializeAttributes(object, options);
}
function serializeDate(date) {
    if (isNaN(date.valueOf())) {
        throw new Error('Cannot serialize an invalid date');
    }
    return { __date: date.toISOString() };
}
exports.serializeDate = serializeDate;
function serializeRegExp(regExp) {
    return { __regExp: regExp.toString() };
}
exports.serializeRegExp = serializeRegExp;
function serializeError(error, options) {
    const serializedError = { __error: error.message };
    return possibly_async_1.possiblyAsync(serializeAttributes(error, options), (serializedAttributes) => {
        Object.assign(serializedError, serializedAttributes);
        return serializedError;
    });
}
exports.serializeError = serializeError;
function serializeAttributes(object, options) {
    return possibly_async_1.possiblyAsync.mapValues(object, (value) => serialize(value, options));
}
function serializeArray(array, options) {
    return possibly_async_1.possiblyAsync.map(array, (item) => serialize(item, options));
}
//# sourceMappingURL=serialization.js.map